{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to urfave/cli \u00b6 urfave/cli is a simple, fast, and fun package for building command line apps in Go. The goal is to enable developers to write fast and distributable command line applications in an expressive way. These are the guides for each major supported version: v2 v1 In addition to the version-specific guides, these other documents are available: CONTRIBUTING CODE OF CONDUCT RELEASING Installation \u00b6 Using this package requires a working Go environment. See the install instructions for Go . Go Modules are required when using this package. See the go blog guide on using Go Modules . Using v2 releases \u00b6 $ go get github.com/urfave/cli/v2 ... import ( \"github.com/urfave/cli/v2\" // imports as package \"cli\" ) ... Using v1 releases \u00b6 $ go get github.com/urfave/cli ... import ( \"github.com/urfave/cli\" ) ... Build tags \u00b6 You can use the following build tags: urfave_cli_no_docs \u00b6 When set, this removes ToMarkdown and ToMan methods, so your application won't be able to call those. This reduces the resulting binary size by about 300-400 KB (measured using Go 1.18.1 on Linux/amd64), due to fewer dependencies. Supported platforms \u00b6 cli is tested against multiple versions of Go on Linux, and against the latest released version of Go on OS X and Windows. This project uses GitHub Actions for builds. To see our currently supported go versions and platforms, look at the github workflow configuration .","title":"Welcome"},{"location":"#welcome-to-urfavecli","text":"urfave/cli is a simple, fast, and fun package for building command line apps in Go. The goal is to enable developers to write fast and distributable command line applications in an expressive way. These are the guides for each major supported version: v2 v1 In addition to the version-specific guides, these other documents are available: CONTRIBUTING CODE OF CONDUCT RELEASING","title":"Welcome to urfave/cli"},{"location":"#installation","text":"Using this package requires a working Go environment. See the install instructions for Go . Go Modules are required when using this package. See the go blog guide on using Go Modules .","title":"Installation"},{"location":"#using-v2-releases","text":"$ go get github.com/urfave/cli/v2 ... import ( \"github.com/urfave/cli/v2\" // imports as package \"cli\" ) ...","title":"Using v2 releases"},{"location":"#using-v1-releases","text":"$ go get github.com/urfave/cli ... import ( \"github.com/urfave/cli\" ) ...","title":"Using v1 releases"},{"location":"#build-tags","text":"You can use the following build tags:","title":"Build tags"},{"location":"#urfave_cli_no_docs","text":"When set, this removes ToMarkdown and ToMan methods, so your application won't be able to call those. This reduces the resulting binary size by about 300-400 KB (measured using Go 1.18.1 on Linux/amd64), due to fewer dependencies.","title":"urfave_cli_no_docs"},{"location":"#supported-platforms","text":"cli is tested against multiple versions of Go on Linux, and against the latest released version of Go on OS X and Windows. This project uses GitHub Actions for builds. To see our currently supported go versions and platforms, look at the github workflow configuration .","title":"Supported platforms"},{"location":"CHANGELOG/","text":"This document is no longer being actively maintained. Please see the releases page for all release notes and related hypermedia for releases >= 1.22.5 , >= 2.3.0 . Change Log \u00b6 ATTN : This project uses semantic versioning . Unreleased - 2.X series \u00b6 View unreleased 2.X series changes. 2.2.0 - 2020-03-08 \u00b6 These release notes were written for the git hash d648edd48d89ef3a841b1ec75c2ebbd4de5f748f Fixed \u00b6 Fixed zsh completion scripts in urfave/cli/pull/1062 via @zhsj Fixed description of subcommand to be more consistent in urfave/cli/pull/1054 via @itchyny Fixed possible runtime panic in slice parsing in urfave/cli/pull/1049 via @saschagrunert Fixed invalid man page header generation in urfave/cli/pull/1041 via @saschagrunert Changed \u00b6 Improved auto-completion instructions and added example gifs in urfave/cli/pull/1059 via @masonj188 Removed the author from generated man pages in urfave/cli/pull/1041 via @saschagrunert Added \u00b6 Added destination field to StringSliceFlag in urfave/cli/pull/1078 via @davidsbond Added HideHelpCommand . While HideHelp hides both help command and --help flag, HideHelpCommand only hides help command and leave --help flag as-is in urfave/cli/pull/1083 via @AkihiroSuda Added timestampFlag docs in urfave/cli/pull/997 via @drov0 Added required flags documentation in urfave/cli/pull/1008 via @lynncyrin , @anberns 2.1.1 - 2019-12-24 \u00b6 Fixed \u00b6 Fixed a Context regression introduced in v2.1.0 in urfave/cli/pull/1014 via @lynncyrin 2.1.0 - 2019-12-24 \u00b6 These release notes were written for the git hash ae84df4cef4a2a6f1a0cb1d41ea0f3af8755e5a8 Fixed \u00b6 Fixed some golint errors in urfave/cli/pull/988 via @liamchampton Fixed a panic with flag completion urfave/cli/pull/946 via @unRob Changed \u00b6 Changed docs generation to use visible flags in urfave/cli/pull/999 via @subpop Changed App.Run to use an optional context for timeouts and cancellation in urfave/cli/pull/975 via @marwan-at-work Changed version info to be hidden if the user has not defined a version in urfave/cli/pull/955 via @asahasrabuddhe Changed docs generation to take into account multiple authors in urfave/cli/pull/900 via @saschagrunert Changed context to expose a Value accessor in urfave/cli/pull/741 via @corruptmemory Added \u00b6 Added timestamp flag in urfave/cli/pull/987 via @drov0 2.0.0 - 2019-11-17 \u00b6 The V2 changes were all shipped in urfave/cli/pull/892 , which was created with the effort of over a dozen participants! They are: @asahasrabuddhe , @meatballhat , @jszwedko , @lynncyrin , @AudriusButkevicius , @saschagrunert , @rliebz , @johnweldon , @nlewo , @grubernaut , @OneOfOne , @VMitov , @cbranch , @marwan-at-work , @uudashr , @bfreis Added \u00b6 Added NewStringSlice and NewIntSlice for creating their related types Added Float64SliceFlag for unmarshaling a list of floats from the user Added Context.Lineage to get all contexts from current up to global Added Context.LocalFlagNames to get the flag names from only the current context Added BoolFlag.Value to handle both default-false and default-true Added IsSet method to the Flag interface which allows us to detect whether or not a flag has been set Changed \u00b6 Context.FlagNames now returns all flags in the context lineage Context.IsSet now considers the full context lineage Removed \u00b6 Removed the ability to specify &StringSlice{...string} or &IntSlice{...int} . Removed adapter code for deprecated Action func signature Deprecated App.Author , App.Email , and Command.ShortName fields Removed all Context.Global* methods, as the non-global versions now traverse up the context lineage automatically. Removed Context.Parent method, as this is now available via Context.Lineage Removed BoolTFlag and related code, as this is now available via BoolFlag.Value Unreleased - 1.22.X series \u00b6 View unreleased 1.22.X series changes. 1.22.4 - 2020-03-31 \u00b6 Fixed \u00b6 Fixed a panic with flag completion in urfave/cli/pull/1101 via @unRob , @VirrageS 1.22.3 - 2020-02-25 \u00b6 Fixed \u00b6 String flag no longer persists the default value if the flag is explicitly initialized in urfave/cli/pull/981 via @asahasrabuddhe context.IsSet() returns true or false correctly regardless of whether the short name or the full name of the flag is passed to it in urfave/cli/pull/978 via @asahasrabuddhe Hide version if the version is not set by the user in urfave/cli/pull/954 via @asahasrabuddhe 1.22.2 - 2019-11-17 \u00b6 Fixed \u00b6 Fix v1.21.0 pass through regression in urfave/cli/pull/872 via @lynncyrin Fix infinite loop when parsing invalid flags for apps with short option handling in urfave/cli/pull/911 via @rliebz Fix zsh autocomplete in urfave/cli/pull/906 via @gnowxilef Fix typo in DocGenerationFlag.TakesValue() docstring in urfave/cli/pull/902 via @benmoose Avoid panic for missing flag value in urfave/cli/pull/893 via @rliebz Changed \u00b6 Simplify HelpPrinter and CustomHelpPrinter behaviors in urfave/cli/pull/912 via @rliebz 1.22.1 - 2019-09-11 \u00b6 Fixed \u00b6 Hide output of hidden commands on man pages in urfave/cli/pull/889 via @crosbymichael Don't generate fish completion for hidden commands urfave/cli/pull/891 via @saschagrunert Using short flag names for required flags throws an error in urfave/cli/pull/890 via @asahasrabuddhe Changed \u00b6 Remove flag code generation logic, legacy python test runner in urfave/cli/pull/883 via @asahasrabuddhe Enable Go Modules support, drop support for Go 1.10 add support for Go 1.13 in urfave/cli/pull/885 via @asahasrabuddhe 1.22.0 - 2019-09-07 \u00b6 Fixed \u00b6 Fix Subcommands not falling back to app.ExitEventHandler in urfave/cli/pull/856 via @FaranIdo Changed \u00b6 Clarify that altsrc supports both TOML and JSON in urfave/cli/pull/774 via @whereswaldon Made the exit code example more clear in urfave/cli/pull/823 via @xordspar0 Removed the use of python for internal flag generation in urfave/cli/pull/836 via @asahasrabuddhe Changed the supported go versions to 1.10 , 1.11 , 1.12 in urfave/cli/pull/843 via @lafriks Changed the v1 releases section in the readme in urfave/cli/pull/862 via @russoj88 Cleaned up go modules in urfave/cli/pull/874 via @saschagrunert Added \u00b6 Added UseShortOptionHandling for combining short flags in urfave/cli/pull/735 via @rliebz Added support for flags bash completion in urfave/cli/pull/808 via @yogeshlonkar Added the TakesFile indicator to flag in urfave/cli/pull/851 via @saschagrunert Added fish shell completion support in urfave/cli/pull/848 via @saschagrunert 1.21.0 - 2019-08-02 \u00b6 Fixed \u00b6 Fix using \"slice\" flag types with EnvVar in urfave/cli/pull/687 via @joshuarubin Fix regression of SkipFlagParsing behavior in urfave/cli/pull/697 via @jszwedko Fix handling ShortOptions and SkipArgReorder in urfave/cli/pull/686 via @baude Fix args reordering when bool flags are present in urfave/cli/pull/712 via @windler Fix parsing of short options in urfave/cli/pull/758 via @vrothberg Fix unaligned indents for the command help messages in urfave/cli/pull/806 via @mingrammer Changed \u00b6 Cleaned up help output in urfave/cli/pull/664 via @maguro Remove redundant nil checks in urfave/cli/pull/773 via @teresy Case is now considered when sorting strings in urfave/cli/pull/676 via @rliebz Added \u00b6 Added \"required flags\" support in urfave/cli/pull/819 via @lynncyrin Backport JSON InputSource to v1 in urfave/cli/pull/598 via @jszwedko Allow more customization of flag help strings in urfave/cli/pull/661 via @rliebz Allow custom ExitError handler function in urfave/cli/pull/628 via @phinnaeus Allow loading a variable from a file in urfave/cli/pull/675 via @jmccann Allow combining short bool names in urfave/cli/pull/684 via @baude Added test coverage to context in urfave/cli/pull/788 via @benzvan Added go module support in urfave/cli/pull/831 via @saschagrunert 1.20.0 - 2017-08-10 \u00b6 Fixed \u00b6 HandleExitCoder is now correctly iterates over all errors in a MultiError . The exit code is the exit code of the last error or 1 if there are no ExitCoder s in the MultiError . Fixed YAML file loading on Windows (previously would fail validate the file path) Subcommand Usage , Description , ArgsUsage , OnUsageError correctly propagated ErrWriter is now passed downwards through command structure to avoid the need to redefine it Pass Command context into OnUsageError rather than parent context so that all fields are available Errors occurring in Before funcs are no longer double printed Use UsageText in the help templates for commands and subcommands if defined; otherwise build the usage as before (was previously ignoring this field) IsSet and GlobalIsSet now correctly return whether a flag is set if a program calls Set or GlobalSet directly after flag parsing (would previously only return true if the flag was set during parsing) Changed \u00b6 No longer exit the program on command/subcommand error if the error raised is not an OsExiter . This exiting behavior was introduced in 1.19.0, but was determined to be a regression in functionality. See the PR for discussion. Added \u00b6 CommandsByName type was added to make it easy to sort Command s by name, alphabetically altsrc now handles loading of string and int arrays from TOML Support for definition of custom help templates for App via CustomAppHelpTemplate Support for arbitrary key/value fields on App to be used with CustomAppHelpTemplate via ExtraInfo HelpFlag , VersionFlag , and BashCompletionFlag changed to explicitly be cli.Flag s allowing for the use of custom flags satisfying the cli.Flag interface to be used. 1.19.1 - 2016-11-21 \u00b6 Fixed \u00b6 Fixes regression introduced in 1.19.0 where using an ActionFunc as the Action for a command would cause it to error rather than calling the function. Should not have a affected declarative cases using func(c *cli.Context) err) . Shell completion now handles the case where the user specifies --generate-bash-completion immediately after a flag that takes an argument. Previously it call the application with --generate-bash-completion as the flag value. 1.19.0 - 2016-11-19 \u00b6 Added \u00b6 FlagsByName was added to make it easy to sort flags (e.g. sort.Sort(cli.FlagsByName(app.Flags)) ) A Description field was added to App for a more detailed description of the application (similar to the existing Description field on Command ) Flag type code generation via go generate Write to stderr and exit 1 if action returns non-nil error Added support for TOML to the altsrc loader SkipArgReorder was added to allow users to skip the argument reordering. This is useful if you want to consider all \"flags\" after an argument as arguments rather than flags (the default behavior of the stdlib flag library). This is backported functionality from the removal of the flag reordering in the unreleased version 2 For formatted errors (those implementing ErrorFormatter ), the errors will be formatted during output. Compatible with pkg/errors . Changed \u00b6 Raise minimum tested/supported Go version to 1.2+ Fixed \u00b6 Consider empty environment variables as set (previously environment variables with the equivalent of \"\" would be skipped rather than their value used). Return an error if the value in a given environment variable cannot be parsed as the flag type. Previously these errors were silently swallowed. Print full error when an invalid flag is specified (which includes the invalid flag) App.Writer defaults to stdout when nil If no action is specified on a command or app, the help is now printed instead of panic ing App.Metadata is initialized automatically now (previously was nil unless initialized) Correctly show help message if -h is provided to a subcommand context.(Global)IsSet now respects environment variables. Previously it would return false if a flag was specified in the environment rather than as an argument Removed deprecation warnings to STDERR to avoid them leaking to the end-user altsrc s import paths were updated to use gopkg.in/urfave/cli.v1 . This fixes issues that occurred when gopkg.in/urfave/cli.v1 was imported as well as altsrc where Go would complain that the types didn't match [1.18.1] - 2016-08-28 \u00b6 Fixed \u00b6 Removed deprecation warnings to STDERR to avoid them leaking to the end-user (backported) 1.18.0 - 2016-06-27 \u00b6 Added \u00b6 ./runtests test runner with coverage tracking by default testing on OS X testing on Windows UintFlag , Uint64Flag , and Int64Flag types and supporting code Changed \u00b6 Use spaces for alignment in help/usage output instead of tabs, making the output alignment consistent regardless of tab width Fixed \u00b6 Printing of command aliases in help text Printing of visible flags for both struct and struct pointer flags Display the help subcommand when using CommandCategories No longer swallows panic s that occur within the Action s themselves when detecting the signature of the Action field [1.17.1] - 2016-08-28 \u00b6 Fixed \u00b6 Removed deprecation warnings to STDERR to avoid them leaking to the end-user 1.17.0 - 2016-05-09 \u00b6 Added \u00b6 Pluggable flag-level help text rendering via cli.DefaultFlagStringFunc context.GlobalBoolT was added as an analogue to context.GlobalBool Support for hiding commands by setting Hidden: true -- this will hide the commands in help output Changed \u00b6 Float64Flag , IntFlag , and DurationFlag default values are no longer quoted in help text output. All flag types now include (default: {value}) strings following usage when a default value can be (reasonably) detected. IntSliceFlag and StringSliceFlag usage strings are now more consistent with non-slice flag types Apps now exit with a code of 3 if an unknown subcommand is specified (previously they printed \"No help topic for...\", but still exited 0. This makes it easier to script around apps built using cli since they can trust that a 0 exit code indicated a successful execution. cleanups based on Go Report Card feedback [1.16.1] - 2016-08-28 \u00b6 Fixed \u00b6 Removed deprecation warnings to STDERR to avoid them leaking to the end-user 1.16.0 - 2016-05-02 \u00b6 Added \u00b6 Hidden field on all flag struct types to omit from generated help text Changed \u00b6 BashCompletionFlag ( --enable-bash-completion ) is now omitted from generated help text via the Hidden field Fixed \u00b6 handling of error values in HandleAction and HandleExitCoder 1.15.0 - 2016-04-30 \u00b6 Added \u00b6 This file! Support for placeholders in flag usage strings App.Metadata map for arbitrary data/state management Set and GlobalSet methods on *cli.Context for altering values after parsing. Support for nested lookup of dot-delimited keys in structures loaded from YAML. Changed \u00b6 The App.Action and Command.Action now prefer a return signature of func(*cli.Context) error , as defined by cli.ActionFunc . If a non-nil error is returned, there may be two outcomes: If the error fulfills cli.ExitCoder , then os.Exit will be called automatically Else the error is bubbled up and returned from App.Run Specifying an Action with the legacy return signature of func(*cli.Context) will produce a deprecation message to stderr Specifying an Action that is not a func type will produce a non-zero exit from App.Run Specifying an Action func that has an invalid (input) signature will produce a non-zero exit from App.Run Deprecated \u00b6 cli.App.RunAndExitOnError , which should now be done by returning an error that fulfills cli.ExitCoder to cli.App.Run . the legacy signature for cli.App.Action of func(*cli.Context) , which should now have a return signature of func(*cli.Context) error , as defined by cli.ActionFunc . Fixed \u00b6 Added missing *cli.Context.GlobalFloat64 method 1.14.0 - 2016-04-03 (backfilled 2016-04-25) \u00b6 Added \u00b6 Codebeat badge Support for categorization via CategorizedHelp and Categories on app. Changed \u00b6 Use filepath.Base instead of path.Base in Name and HelpName . Fixed \u00b6 Ensure version is not shown in help text when HideVersion set. 1.13.0 - 2016-03-06 (backfilled 2016-04-25) \u00b6 Added \u00b6 YAML file input support. NArg method on context. 1.12.0 - 2016-02-17 (backfilled 2016-04-25) \u00b6 Added \u00b6 Custom usage error handling. Custom text support in USAGE section of help output. Improved help messages for empty strings. AppVeyor CI configuration. Changed \u00b6 Removed panic from default help printer func. De-duping and optimizations. Fixed \u00b6 Correctly handle Before / After at command level when no subcommands. Case of literal - argument causing flag reordering. Environment variable hints on Windows. Docs updates. 1.11.1 - 2015-12-21 (backfilled 2016-04-25) \u00b6 Changed \u00b6 Use path.Base in Name and HelpName Export GetName on flag types. Fixed \u00b6 Flag parsing when skipping is enabled. Test output cleanup. Move completion check to account for empty input case. 1.11.0 - 2015-11-15 (backfilled 2016-04-25) \u00b6 Added \u00b6 Destination scan support for flags. Testing against tip in Travis CI config. Changed \u00b6 Go version in Travis CI config. Fixed \u00b6 Removed redundant tests. Use correct example naming in tests. 1.10.2 - 2015-10-29 (backfilled 2016-04-25) \u00b6 Fixed \u00b6 Remove unused var in bash completion. 1.10.1 - 2015-10-21 (backfilled 2016-04-25) \u00b6 Added \u00b6 Coverage and reference logos in README. Fixed \u00b6 Use specified values in help and version parsing. Only display app version and help message once. 1.10.0 - 2015-10-06 (backfilled 2016-04-25) \u00b6 Added \u00b6 More tests for existing functionality. ArgsUsage at app and command level for help text flexibility. Fixed \u00b6 Honor HideHelp and HideVersion in App.Run . Remove juvenile word from README. 1.9.0 - 2015-09-08 (backfilled 2016-04-25) \u00b6 Added \u00b6 FullName on command with accompanying help output update. Set default $PROG in bash completion. Changed \u00b6 Docs formatting. Fixed \u00b6 Removed self-referential imports in tests. 1.8.0 - 2015-06-30 (backfilled 2016-04-25) \u00b6 Added \u00b6 Support for Copyright at app level. Parent func at context level to walk up context lineage. Fixed \u00b6 Global flag processing at top level. 1.7.1 - 2015-06-11 (backfilled 2016-04-25) \u00b6 Added \u00b6 Aggregate errors from Before / After funcs. Doc comments on flag structs. Include non-global flags when checking version and help. Travis CI config updates. Fixed \u00b6 Ensure slice type flags have non-nil values. Collect global flags from the full command hierarchy. Docs prose. 1.7.0 - 2015-05-03 (backfilled 2016-04-25) \u00b6 Changed \u00b6 HelpPrinter signature includes output writer. Fixed \u00b6 Specify go 1.1+ in docs. Set Writer when running command as app. 1.6.0 - 2015-03-23 (backfilled 2016-04-25) \u00b6 Added \u00b6 Multiple author support. NumFlags at context level. Aliases at command level. Deprecated \u00b6 ShortName at command level. Fixed \u00b6 Subcommand help output. Backward compatible support for deprecated Author and Email fields. Docs regarding Names / Aliases . 1.5.0 - 2015-02-20 (backfilled 2016-04-25) \u00b6 Added \u00b6 After hook func support at app and command level. Fixed \u00b6 Use parsed context when running command as subcommand. Docs prose. 1.4.1 - 2015-01-09 (backfilled 2016-04-25) \u00b6 Added \u00b6 Support for hiding -h / --help flags, but not help subcommand. Stop flag parsing after -- . Fixed \u00b6 Help text for generic flags to specify single value. Use double quotes in output for defaults. Use ParseInt instead of ParseUint for int environment var values. Use 0 as base when parsing int environment var values. 1.4.0 - 2014-12-12 (backfilled 2016-04-25) \u00b6 Added \u00b6 Support for environment variable lookup \"cascade\". Support for Stdout on app for output redirection. Fixed \u00b6 Print command help instead of app help in ShowCommandHelp . 1.3.1 - 2014-11-13 (backfilled 2016-04-25) \u00b6 Added \u00b6 Docs and example code updates. Changed \u00b6 Default -v / --version flag made optional. 1.3.0 - 2014-08-10 (backfilled 2016-04-25) \u00b6 Added \u00b6 FlagNames at context level. Exposed VersionPrinter var for more control over version output. Zsh completion hook. AUTHOR section in default app help template. Contribution guidelines. DurationFlag type. 1.2.0 - 2014-08-02 \u00b6 Added \u00b6 Support for environment variable defaults on flags plus tests. 1.1.0 - 2014-07-15 \u00b6 Added \u00b6 Bash completion. Optional hiding of built-in help command. Optional skipping of flag parsing at command level. Author , Email , and Compiled metadata on app. Before hook func support at app and command level. CommandNotFound func support at app level. Command reference available on context. GenericFlag type. Float64Flag type. BoolTFlag type. IsSet flag helper on context. More flag lookup funcs at context level. More tests & docs. Changed \u00b6 Help template updates to account for presence/absence of flags. Separated subcommand help template. Exposed HelpPrinter var for more control over help output. 1.0.0 - 2013-11-01 \u00b6 Added \u00b6 help flag in default app flag set and each command flag set. Custom handling of argument parsing errors. Command lookup by name at app level. StringSliceFlag type and supporting StringSlice type. IntSliceFlag type and supporting IntSlice type. Slice type flag lookups by name at context level. Export of app and command help functions. More tests & docs. 0.1.0 - 2013-07-22 \u00b6 Added \u00b6 Initial implementation.","title":"CHANGELOG"},{"location":"CHANGELOG/#change-log","text":"ATTN : This project uses semantic versioning .","title":"Change Log"},{"location":"CHANGELOG/#unreleased-2x-series","text":"View unreleased 2.X series changes.","title":"Unreleased - 2.X series"},{"location":"CHANGELOG/#220-2020-03-08","text":"These release notes were written for the git hash d648edd48d89ef3a841b1ec75c2ebbd4de5f748f","title":"2.2.0 - 2020-03-08"},{"location":"CHANGELOG/#fixed","text":"Fixed zsh completion scripts in urfave/cli/pull/1062 via @zhsj Fixed description of subcommand to be more consistent in urfave/cli/pull/1054 via @itchyny Fixed possible runtime panic in slice parsing in urfave/cli/pull/1049 via @saschagrunert Fixed invalid man page header generation in urfave/cli/pull/1041 via @saschagrunert","title":"Fixed"},{"location":"CHANGELOG/#changed","text":"Improved auto-completion instructions and added example gifs in urfave/cli/pull/1059 via @masonj188 Removed the author from generated man pages in urfave/cli/pull/1041 via @saschagrunert","title":"Changed"},{"location":"CHANGELOG/#added","text":"Added destination field to StringSliceFlag in urfave/cli/pull/1078 via @davidsbond Added HideHelpCommand . While HideHelp hides both help command and --help flag, HideHelpCommand only hides help command and leave --help flag as-is in urfave/cli/pull/1083 via @AkihiroSuda Added timestampFlag docs in urfave/cli/pull/997 via @drov0 Added required flags documentation in urfave/cli/pull/1008 via @lynncyrin , @anberns","title":"Added"},{"location":"CHANGELOG/#211-2019-12-24","text":"","title":"2.1.1 - 2019-12-24"},{"location":"CHANGELOG/#fixed_1","text":"Fixed a Context regression introduced in v2.1.0 in urfave/cli/pull/1014 via @lynncyrin","title":"Fixed"},{"location":"CHANGELOG/#210-2019-12-24","text":"These release notes were written for the git hash ae84df4cef4a2a6f1a0cb1d41ea0f3af8755e5a8","title":"2.1.0 - 2019-12-24"},{"location":"CHANGELOG/#fixed_2","text":"Fixed some golint errors in urfave/cli/pull/988 via @liamchampton Fixed a panic with flag completion urfave/cli/pull/946 via @unRob","title":"Fixed"},{"location":"CHANGELOG/#changed_1","text":"Changed docs generation to use visible flags in urfave/cli/pull/999 via @subpop Changed App.Run to use an optional context for timeouts and cancellation in urfave/cli/pull/975 via @marwan-at-work Changed version info to be hidden if the user has not defined a version in urfave/cli/pull/955 via @asahasrabuddhe Changed docs generation to take into account multiple authors in urfave/cli/pull/900 via @saschagrunert Changed context to expose a Value accessor in urfave/cli/pull/741 via @corruptmemory","title":"Changed"},{"location":"CHANGELOG/#added_1","text":"Added timestamp flag in urfave/cli/pull/987 via @drov0","title":"Added"},{"location":"CHANGELOG/#200-2019-11-17","text":"The V2 changes were all shipped in urfave/cli/pull/892 , which was created with the effort of over a dozen participants! They are: @asahasrabuddhe , @meatballhat , @jszwedko , @lynncyrin , @AudriusButkevicius , @saschagrunert , @rliebz , @johnweldon , @nlewo , @grubernaut , @OneOfOne , @VMitov , @cbranch , @marwan-at-work , @uudashr , @bfreis","title":"2.0.0 - 2019-11-17"},{"location":"CHANGELOG/#added_2","text":"Added NewStringSlice and NewIntSlice for creating their related types Added Float64SliceFlag for unmarshaling a list of floats from the user Added Context.Lineage to get all contexts from current up to global Added Context.LocalFlagNames to get the flag names from only the current context Added BoolFlag.Value to handle both default-false and default-true Added IsSet method to the Flag interface which allows us to detect whether or not a flag has been set","title":"Added"},{"location":"CHANGELOG/#changed_2","text":"Context.FlagNames now returns all flags in the context lineage Context.IsSet now considers the full context lineage","title":"Changed"},{"location":"CHANGELOG/#removed","text":"Removed the ability to specify &StringSlice{...string} or &IntSlice{...int} . Removed adapter code for deprecated Action func signature Deprecated App.Author , App.Email , and Command.ShortName fields Removed all Context.Global* methods, as the non-global versions now traverse up the context lineage automatically. Removed Context.Parent method, as this is now available via Context.Lineage Removed BoolTFlag and related code, as this is now available via BoolFlag.Value","title":"Removed"},{"location":"CHANGELOG/#unreleased-122x-series","text":"View unreleased 1.22.X series changes.","title":"Unreleased - 1.22.X series"},{"location":"CHANGELOG/#1224-2020-03-31","text":"","title":"1.22.4 - 2020-03-31"},{"location":"CHANGELOG/#fixed_3","text":"Fixed a panic with flag completion in urfave/cli/pull/1101 via @unRob , @VirrageS","title":"Fixed"},{"location":"CHANGELOG/#1223-2020-02-25","text":"","title":"1.22.3 - 2020-02-25"},{"location":"CHANGELOG/#fixed_4","text":"String flag no longer persists the default value if the flag is explicitly initialized in urfave/cli/pull/981 via @asahasrabuddhe context.IsSet() returns true or false correctly regardless of whether the short name or the full name of the flag is passed to it in urfave/cli/pull/978 via @asahasrabuddhe Hide version if the version is not set by the user in urfave/cli/pull/954 via @asahasrabuddhe","title":"Fixed"},{"location":"CHANGELOG/#1222-2019-11-17","text":"","title":"1.22.2 - 2019-11-17"},{"location":"CHANGELOG/#fixed_5","text":"Fix v1.21.0 pass through regression in urfave/cli/pull/872 via @lynncyrin Fix infinite loop when parsing invalid flags for apps with short option handling in urfave/cli/pull/911 via @rliebz Fix zsh autocomplete in urfave/cli/pull/906 via @gnowxilef Fix typo in DocGenerationFlag.TakesValue() docstring in urfave/cli/pull/902 via @benmoose Avoid panic for missing flag value in urfave/cli/pull/893 via @rliebz","title":"Fixed"},{"location":"CHANGELOG/#changed_3","text":"Simplify HelpPrinter and CustomHelpPrinter behaviors in urfave/cli/pull/912 via @rliebz","title":"Changed"},{"location":"CHANGELOG/#1221-2019-09-11","text":"","title":"1.22.1 - 2019-09-11"},{"location":"CHANGELOG/#fixed_6","text":"Hide output of hidden commands on man pages in urfave/cli/pull/889 via @crosbymichael Don't generate fish completion for hidden commands urfave/cli/pull/891 via @saschagrunert Using short flag names for required flags throws an error in urfave/cli/pull/890 via @asahasrabuddhe","title":"Fixed"},{"location":"CHANGELOG/#changed_4","text":"Remove flag code generation logic, legacy python test runner in urfave/cli/pull/883 via @asahasrabuddhe Enable Go Modules support, drop support for Go 1.10 add support for Go 1.13 in urfave/cli/pull/885 via @asahasrabuddhe","title":"Changed"},{"location":"CHANGELOG/#1220-2019-09-07","text":"","title":"1.22.0 - 2019-09-07"},{"location":"CHANGELOG/#fixed_7","text":"Fix Subcommands not falling back to app.ExitEventHandler in urfave/cli/pull/856 via @FaranIdo","title":"Fixed"},{"location":"CHANGELOG/#changed_5","text":"Clarify that altsrc supports both TOML and JSON in urfave/cli/pull/774 via @whereswaldon Made the exit code example more clear in urfave/cli/pull/823 via @xordspar0 Removed the use of python for internal flag generation in urfave/cli/pull/836 via @asahasrabuddhe Changed the supported go versions to 1.10 , 1.11 , 1.12 in urfave/cli/pull/843 via @lafriks Changed the v1 releases section in the readme in urfave/cli/pull/862 via @russoj88 Cleaned up go modules in urfave/cli/pull/874 via @saschagrunert","title":"Changed"},{"location":"CHANGELOG/#added_3","text":"Added UseShortOptionHandling for combining short flags in urfave/cli/pull/735 via @rliebz Added support for flags bash completion in urfave/cli/pull/808 via @yogeshlonkar Added the TakesFile indicator to flag in urfave/cli/pull/851 via @saschagrunert Added fish shell completion support in urfave/cli/pull/848 via @saschagrunert","title":"Added"},{"location":"CHANGELOG/#1210-2019-08-02","text":"","title":"1.21.0 - 2019-08-02"},{"location":"CHANGELOG/#fixed_8","text":"Fix using \"slice\" flag types with EnvVar in urfave/cli/pull/687 via @joshuarubin Fix regression of SkipFlagParsing behavior in urfave/cli/pull/697 via @jszwedko Fix handling ShortOptions and SkipArgReorder in urfave/cli/pull/686 via @baude Fix args reordering when bool flags are present in urfave/cli/pull/712 via @windler Fix parsing of short options in urfave/cli/pull/758 via @vrothberg Fix unaligned indents for the command help messages in urfave/cli/pull/806 via @mingrammer","title":"Fixed"},{"location":"CHANGELOG/#changed_6","text":"Cleaned up help output in urfave/cli/pull/664 via @maguro Remove redundant nil checks in urfave/cli/pull/773 via @teresy Case is now considered when sorting strings in urfave/cli/pull/676 via @rliebz","title":"Changed"},{"location":"CHANGELOG/#added_4","text":"Added \"required flags\" support in urfave/cli/pull/819 via @lynncyrin Backport JSON InputSource to v1 in urfave/cli/pull/598 via @jszwedko Allow more customization of flag help strings in urfave/cli/pull/661 via @rliebz Allow custom ExitError handler function in urfave/cli/pull/628 via @phinnaeus Allow loading a variable from a file in urfave/cli/pull/675 via @jmccann Allow combining short bool names in urfave/cli/pull/684 via @baude Added test coverage to context in urfave/cli/pull/788 via @benzvan Added go module support in urfave/cli/pull/831 via @saschagrunert","title":"Added"},{"location":"CHANGELOG/#1200-2017-08-10","text":"","title":"1.20.0 - 2017-08-10"},{"location":"CHANGELOG/#fixed_9","text":"HandleExitCoder is now correctly iterates over all errors in a MultiError . The exit code is the exit code of the last error or 1 if there are no ExitCoder s in the MultiError . Fixed YAML file loading on Windows (previously would fail validate the file path) Subcommand Usage , Description , ArgsUsage , OnUsageError correctly propagated ErrWriter is now passed downwards through command structure to avoid the need to redefine it Pass Command context into OnUsageError rather than parent context so that all fields are available Errors occurring in Before funcs are no longer double printed Use UsageText in the help templates for commands and subcommands if defined; otherwise build the usage as before (was previously ignoring this field) IsSet and GlobalIsSet now correctly return whether a flag is set if a program calls Set or GlobalSet directly after flag parsing (would previously only return true if the flag was set during parsing)","title":"Fixed"},{"location":"CHANGELOG/#changed_7","text":"No longer exit the program on command/subcommand error if the error raised is not an OsExiter . This exiting behavior was introduced in 1.19.0, but was determined to be a regression in functionality. See the PR for discussion.","title":"Changed"},{"location":"CHANGELOG/#added_5","text":"CommandsByName type was added to make it easy to sort Command s by name, alphabetically altsrc now handles loading of string and int arrays from TOML Support for definition of custom help templates for App via CustomAppHelpTemplate Support for arbitrary key/value fields on App to be used with CustomAppHelpTemplate via ExtraInfo HelpFlag , VersionFlag , and BashCompletionFlag changed to explicitly be cli.Flag s allowing for the use of custom flags satisfying the cli.Flag interface to be used.","title":"Added"},{"location":"CHANGELOG/#1191-2016-11-21","text":"","title":"1.19.1 - 2016-11-21"},{"location":"CHANGELOG/#fixed_10","text":"Fixes regression introduced in 1.19.0 where using an ActionFunc as the Action for a command would cause it to error rather than calling the function. Should not have a affected declarative cases using func(c *cli.Context) err) . Shell completion now handles the case where the user specifies --generate-bash-completion immediately after a flag that takes an argument. Previously it call the application with --generate-bash-completion as the flag value.","title":"Fixed"},{"location":"CHANGELOG/#1190-2016-11-19","text":"","title":"1.19.0 - 2016-11-19"},{"location":"CHANGELOG/#added_6","text":"FlagsByName was added to make it easy to sort flags (e.g. sort.Sort(cli.FlagsByName(app.Flags)) ) A Description field was added to App for a more detailed description of the application (similar to the existing Description field on Command ) Flag type code generation via go generate Write to stderr and exit 1 if action returns non-nil error Added support for TOML to the altsrc loader SkipArgReorder was added to allow users to skip the argument reordering. This is useful if you want to consider all \"flags\" after an argument as arguments rather than flags (the default behavior of the stdlib flag library). This is backported functionality from the removal of the flag reordering in the unreleased version 2 For formatted errors (those implementing ErrorFormatter ), the errors will be formatted during output. Compatible with pkg/errors .","title":"Added"},{"location":"CHANGELOG/#changed_8","text":"Raise minimum tested/supported Go version to 1.2+","title":"Changed"},{"location":"CHANGELOG/#fixed_11","text":"Consider empty environment variables as set (previously environment variables with the equivalent of \"\" would be skipped rather than their value used). Return an error if the value in a given environment variable cannot be parsed as the flag type. Previously these errors were silently swallowed. Print full error when an invalid flag is specified (which includes the invalid flag) App.Writer defaults to stdout when nil If no action is specified on a command or app, the help is now printed instead of panic ing App.Metadata is initialized automatically now (previously was nil unless initialized) Correctly show help message if -h is provided to a subcommand context.(Global)IsSet now respects environment variables. Previously it would return false if a flag was specified in the environment rather than as an argument Removed deprecation warnings to STDERR to avoid them leaking to the end-user altsrc s import paths were updated to use gopkg.in/urfave/cli.v1 . This fixes issues that occurred when gopkg.in/urfave/cli.v1 was imported as well as altsrc where Go would complain that the types didn't match","title":"Fixed"},{"location":"CHANGELOG/#1181-2016-08-28","text":"","title":"[1.18.1] - 2016-08-28"},{"location":"CHANGELOG/#fixed_12","text":"Removed deprecation warnings to STDERR to avoid them leaking to the end-user (backported)","title":"Fixed"},{"location":"CHANGELOG/#1180-2016-06-27","text":"","title":"1.18.0 - 2016-06-27"},{"location":"CHANGELOG/#added_7","text":"./runtests test runner with coverage tracking by default testing on OS X testing on Windows UintFlag , Uint64Flag , and Int64Flag types and supporting code","title":"Added"},{"location":"CHANGELOG/#changed_9","text":"Use spaces for alignment in help/usage output instead of tabs, making the output alignment consistent regardless of tab width","title":"Changed"},{"location":"CHANGELOG/#fixed_13","text":"Printing of command aliases in help text Printing of visible flags for both struct and struct pointer flags Display the help subcommand when using CommandCategories No longer swallows panic s that occur within the Action s themselves when detecting the signature of the Action field","title":"Fixed"},{"location":"CHANGELOG/#1171-2016-08-28","text":"","title":"[1.17.1] - 2016-08-28"},{"location":"CHANGELOG/#fixed_14","text":"Removed deprecation warnings to STDERR to avoid them leaking to the end-user","title":"Fixed"},{"location":"CHANGELOG/#1170-2016-05-09","text":"","title":"1.17.0 - 2016-05-09"},{"location":"CHANGELOG/#added_8","text":"Pluggable flag-level help text rendering via cli.DefaultFlagStringFunc context.GlobalBoolT was added as an analogue to context.GlobalBool Support for hiding commands by setting Hidden: true -- this will hide the commands in help output","title":"Added"},{"location":"CHANGELOG/#changed_10","text":"Float64Flag , IntFlag , and DurationFlag default values are no longer quoted in help text output. All flag types now include (default: {value}) strings following usage when a default value can be (reasonably) detected. IntSliceFlag and StringSliceFlag usage strings are now more consistent with non-slice flag types Apps now exit with a code of 3 if an unknown subcommand is specified (previously they printed \"No help topic for...\", but still exited 0. This makes it easier to script around apps built using cli since they can trust that a 0 exit code indicated a successful execution. cleanups based on Go Report Card feedback","title":"Changed"},{"location":"CHANGELOG/#1161-2016-08-28","text":"","title":"[1.16.1] - 2016-08-28"},{"location":"CHANGELOG/#fixed_15","text":"Removed deprecation warnings to STDERR to avoid them leaking to the end-user","title":"Fixed"},{"location":"CHANGELOG/#1160-2016-05-02","text":"","title":"1.16.0 - 2016-05-02"},{"location":"CHANGELOG/#added_9","text":"Hidden field on all flag struct types to omit from generated help text","title":"Added"},{"location":"CHANGELOG/#changed_11","text":"BashCompletionFlag ( --enable-bash-completion ) is now omitted from generated help text via the Hidden field","title":"Changed"},{"location":"CHANGELOG/#fixed_16","text":"handling of error values in HandleAction and HandleExitCoder","title":"Fixed"},{"location":"CHANGELOG/#1150-2016-04-30","text":"","title":"1.15.0 - 2016-04-30"},{"location":"CHANGELOG/#added_10","text":"This file! Support for placeholders in flag usage strings App.Metadata map for arbitrary data/state management Set and GlobalSet methods on *cli.Context for altering values after parsing. Support for nested lookup of dot-delimited keys in structures loaded from YAML.","title":"Added"},{"location":"CHANGELOG/#changed_12","text":"The App.Action and Command.Action now prefer a return signature of func(*cli.Context) error , as defined by cli.ActionFunc . If a non-nil error is returned, there may be two outcomes: If the error fulfills cli.ExitCoder , then os.Exit will be called automatically Else the error is bubbled up and returned from App.Run Specifying an Action with the legacy return signature of func(*cli.Context) will produce a deprecation message to stderr Specifying an Action that is not a func type will produce a non-zero exit from App.Run Specifying an Action func that has an invalid (input) signature will produce a non-zero exit from App.Run","title":"Changed"},{"location":"CHANGELOG/#deprecated","text":"cli.App.RunAndExitOnError , which should now be done by returning an error that fulfills cli.ExitCoder to cli.App.Run . the legacy signature for cli.App.Action of func(*cli.Context) , which should now have a return signature of func(*cli.Context) error , as defined by cli.ActionFunc .","title":"Deprecated"},{"location":"CHANGELOG/#fixed_17","text":"Added missing *cli.Context.GlobalFloat64 method","title":"Fixed"},{"location":"CHANGELOG/#1140-2016-04-03-backfilled-2016-04-25","text":"","title":"1.14.0 - 2016-04-03 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_11","text":"Codebeat badge Support for categorization via CategorizedHelp and Categories on app.","title":"Added"},{"location":"CHANGELOG/#changed_13","text":"Use filepath.Base instead of path.Base in Name and HelpName .","title":"Changed"},{"location":"CHANGELOG/#fixed_18","text":"Ensure version is not shown in help text when HideVersion set.","title":"Fixed"},{"location":"CHANGELOG/#1130-2016-03-06-backfilled-2016-04-25","text":"","title":"1.13.0 - 2016-03-06 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_12","text":"YAML file input support. NArg method on context.","title":"Added"},{"location":"CHANGELOG/#1120-2016-02-17-backfilled-2016-04-25","text":"","title":"1.12.0 - 2016-02-17 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_13","text":"Custom usage error handling. Custom text support in USAGE section of help output. Improved help messages for empty strings. AppVeyor CI configuration.","title":"Added"},{"location":"CHANGELOG/#changed_14","text":"Removed panic from default help printer func. De-duping and optimizations.","title":"Changed"},{"location":"CHANGELOG/#fixed_19","text":"Correctly handle Before / After at command level when no subcommands. Case of literal - argument causing flag reordering. Environment variable hints on Windows. Docs updates.","title":"Fixed"},{"location":"CHANGELOG/#1111-2015-12-21-backfilled-2016-04-25","text":"","title":"1.11.1 - 2015-12-21 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#changed_15","text":"Use path.Base in Name and HelpName Export GetName on flag types.","title":"Changed"},{"location":"CHANGELOG/#fixed_20","text":"Flag parsing when skipping is enabled. Test output cleanup. Move completion check to account for empty input case.","title":"Fixed"},{"location":"CHANGELOG/#1110-2015-11-15-backfilled-2016-04-25","text":"","title":"1.11.0 - 2015-11-15 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_14","text":"Destination scan support for flags. Testing against tip in Travis CI config.","title":"Added"},{"location":"CHANGELOG/#changed_16","text":"Go version in Travis CI config.","title":"Changed"},{"location":"CHANGELOG/#fixed_21","text":"Removed redundant tests. Use correct example naming in tests.","title":"Fixed"},{"location":"CHANGELOG/#1102-2015-10-29-backfilled-2016-04-25","text":"","title":"1.10.2 - 2015-10-29 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#fixed_22","text":"Remove unused var in bash completion.","title":"Fixed"},{"location":"CHANGELOG/#1101-2015-10-21-backfilled-2016-04-25","text":"","title":"1.10.1 - 2015-10-21 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_15","text":"Coverage and reference logos in README.","title":"Added"},{"location":"CHANGELOG/#fixed_23","text":"Use specified values in help and version parsing. Only display app version and help message once.","title":"Fixed"},{"location":"CHANGELOG/#1100-2015-10-06-backfilled-2016-04-25","text":"","title":"1.10.0 - 2015-10-06 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_16","text":"More tests for existing functionality. ArgsUsage at app and command level for help text flexibility.","title":"Added"},{"location":"CHANGELOG/#fixed_24","text":"Honor HideHelp and HideVersion in App.Run . Remove juvenile word from README.","title":"Fixed"},{"location":"CHANGELOG/#190-2015-09-08-backfilled-2016-04-25","text":"","title":"1.9.0 - 2015-09-08 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_17","text":"FullName on command with accompanying help output update. Set default $PROG in bash completion.","title":"Added"},{"location":"CHANGELOG/#changed_17","text":"Docs formatting.","title":"Changed"},{"location":"CHANGELOG/#fixed_25","text":"Removed self-referential imports in tests.","title":"Fixed"},{"location":"CHANGELOG/#180-2015-06-30-backfilled-2016-04-25","text":"","title":"1.8.0 - 2015-06-30 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_18","text":"Support for Copyright at app level. Parent func at context level to walk up context lineage.","title":"Added"},{"location":"CHANGELOG/#fixed_26","text":"Global flag processing at top level.","title":"Fixed"},{"location":"CHANGELOG/#171-2015-06-11-backfilled-2016-04-25","text":"","title":"1.7.1 - 2015-06-11 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_19","text":"Aggregate errors from Before / After funcs. Doc comments on flag structs. Include non-global flags when checking version and help. Travis CI config updates.","title":"Added"},{"location":"CHANGELOG/#fixed_27","text":"Ensure slice type flags have non-nil values. Collect global flags from the full command hierarchy. Docs prose.","title":"Fixed"},{"location":"CHANGELOG/#170-2015-05-03-backfilled-2016-04-25","text":"","title":"1.7.0 - 2015-05-03 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#changed_18","text":"HelpPrinter signature includes output writer.","title":"Changed"},{"location":"CHANGELOG/#fixed_28","text":"Specify go 1.1+ in docs. Set Writer when running command as app.","title":"Fixed"},{"location":"CHANGELOG/#160-2015-03-23-backfilled-2016-04-25","text":"","title":"1.6.0 - 2015-03-23 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_20","text":"Multiple author support. NumFlags at context level. Aliases at command level.","title":"Added"},{"location":"CHANGELOG/#deprecated_1","text":"ShortName at command level.","title":"Deprecated"},{"location":"CHANGELOG/#fixed_29","text":"Subcommand help output. Backward compatible support for deprecated Author and Email fields. Docs regarding Names / Aliases .","title":"Fixed"},{"location":"CHANGELOG/#150-2015-02-20-backfilled-2016-04-25","text":"","title":"1.5.0 - 2015-02-20 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_21","text":"After hook func support at app and command level.","title":"Added"},{"location":"CHANGELOG/#fixed_30","text":"Use parsed context when running command as subcommand. Docs prose.","title":"Fixed"},{"location":"CHANGELOG/#141-2015-01-09-backfilled-2016-04-25","text":"","title":"1.4.1 - 2015-01-09 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_22","text":"Support for hiding -h / --help flags, but not help subcommand. Stop flag parsing after -- .","title":"Added"},{"location":"CHANGELOG/#fixed_31","text":"Help text for generic flags to specify single value. Use double quotes in output for defaults. Use ParseInt instead of ParseUint for int environment var values. Use 0 as base when parsing int environment var values.","title":"Fixed"},{"location":"CHANGELOG/#140-2014-12-12-backfilled-2016-04-25","text":"","title":"1.4.0 - 2014-12-12 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_23","text":"Support for environment variable lookup \"cascade\". Support for Stdout on app for output redirection.","title":"Added"},{"location":"CHANGELOG/#fixed_32","text":"Print command help instead of app help in ShowCommandHelp .","title":"Fixed"},{"location":"CHANGELOG/#131-2014-11-13-backfilled-2016-04-25","text":"","title":"1.3.1 - 2014-11-13 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_24","text":"Docs and example code updates.","title":"Added"},{"location":"CHANGELOG/#changed_19","text":"Default -v / --version flag made optional.","title":"Changed"},{"location":"CHANGELOG/#130-2014-08-10-backfilled-2016-04-25","text":"","title":"1.3.0 - 2014-08-10 (backfilled 2016-04-25)"},{"location":"CHANGELOG/#added_25","text":"FlagNames at context level. Exposed VersionPrinter var for more control over version output. Zsh completion hook. AUTHOR section in default app help template. Contribution guidelines. DurationFlag type.","title":"Added"},{"location":"CHANGELOG/#120-2014-08-02","text":"","title":"1.2.0 - 2014-08-02"},{"location":"CHANGELOG/#added_26","text":"Support for environment variable defaults on flags plus tests.","title":"Added"},{"location":"CHANGELOG/#110-2014-07-15","text":"","title":"1.1.0 - 2014-07-15"},{"location":"CHANGELOG/#added_27","text":"Bash completion. Optional hiding of built-in help command. Optional skipping of flag parsing at command level. Author , Email , and Compiled metadata on app. Before hook func support at app and command level. CommandNotFound func support at app level. Command reference available on context. GenericFlag type. Float64Flag type. BoolTFlag type. IsSet flag helper on context. More flag lookup funcs at context level. More tests & docs.","title":"Added"},{"location":"CHANGELOG/#changed_20","text":"Help template updates to account for presence/absence of flags. Separated subcommand help template. Exposed HelpPrinter var for more control over help output.","title":"Changed"},{"location":"CHANGELOG/#100-2013-11-01","text":"","title":"1.0.0 - 2013-11-01"},{"location":"CHANGELOG/#added_28","text":"help flag in default app flag set and each command flag set. Custom handling of argument parsing errors. Command lookup by name at app level. StringSliceFlag type and supporting StringSlice type. IntSliceFlag type and supporting IntSlice type. Slice type flag lookups by name at context level. Export of app and command help functions. More tests & docs.","title":"Added"},{"location":"CHANGELOG/#010-2013-07-22","text":"","title":"0.1.0 - 2013-07-22"},{"location":"CHANGELOG/#added_29","text":"Initial implementation.","title":"Added"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting urfave-governance@googlegroups.com, a members-only group that is world-postable. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/\u00bc/code-of-conduct.html","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting urfave-governance@googlegroups.com, a members-only group that is world-postable. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/\u00bc/code-of-conduct.html","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contributing \u00b6 Welcome to the urfave/cli contributor docs! This goal of this document is to help those interested in joining the 200+ humans who have contributed to this project over the years. As a general guiding principle, the current maintainers may be notified via the @urfave/cli GitHub team. All of the current maintainers are volunteers who live in various timezones with different scheduling needs, so please understand that your contribution or question may not get a response for many days. semantic versioning adherence \u00b6 The urfave/cli project strives to strictly adhere to semantic versioning . The active development branches and the milestones and import paths to which they correspond are: main branch \u00b6 https://github.com/urfave/cli/tree/main The majority of active development and issue management is targeting the main branch, which MUST only receive bug fixes and feature additions . v2.x github.com/urfave/cli/v2 The main branch in particular includes tooling to help with keeping the v2.x series backward compatible. More details on this process are in the development workflow section below. v1 branch \u00b6 https://github.com/urfave/cli/tree/v1 The v1 branch MUST only receive bug fixes in the v1.22.x series. There is no strict rule regarding bug fixes to the v2.x series being backported to the v1.22.x series. v1.22.x github.com/urfave/cli v3-dev-main branch \u00b6 https://github.com/urfave/cli/tree/v3-dev-main The v3-dev-branch MUST receive all bug fixes and features added to the main branch and MAY receive feature removals and other changes that are otherwise backward-incompatible with the v2.x series. v3.x unreleased / unsupported development workflow \u00b6 Most of the tooling around the development workflow strives for effective dogfooding . There is a top-level Makefile that is maintained strictly for the purpose of easing verification of one's development environment and any changes one may have introduced: make Running the default make target ( all ) will ensure all of the critical steps are run to verify one's changes are harmonious in nature. The same steps are also run during the continuous integration phase . In the event that the v2diff target exits non-zero, this is a signal that the public API surface area has changed. If the changes adhere to semantic versioning, meaning they are additions or bug fixes , then manually running the approval step will \"promote\" the current go doc output: make v2approve Because the generate step includes updating godoc-current.txt and testdata/godoc-v2.x.txt , these changes MUST be part of any proposed pull request so that reviewers have an opportunity to also make an informed decision about the \"promotion\" step. generated code \u00b6 A significant portion of the project's source code is generated, with the goal being to eliminate repetitive maintenance where other type-safe abstraction is impractical or impossible with Go versions < 1.18 . In a future where the eldest Go version supported is 1.18.x , there will likely be efforts to take advantage of generics . The built-in go generate command is used to run the commands specified in //go:generate directives. Each such command runs a file that also supports a command line help system which may be consulted for further information, e.g.: go run cmd/urfave-cli-genflags/main.go --help docs output \u00b6 The documentation in the docs directory is automatically built via mkdocs into a static site and published when releases are pushed (see RELEASING ). There is no strict requirement to build the documentation when developing locally, but the following make targets may be used if desired: # install documentation dependencies with `pip` make ensure-mkdocs # build the static site in `./site` make docs # start an mkdocs development server make serve-docs pull requests \u00b6 Please feel free to open a pull request to fix a bug or add a feature. The @urfave/cli team will review it as soon as possible, giving special attention to maintaining backward compatibility. If the @urfave/cli team agrees that your contribution is in line with the vision of the project, they will work with you to get the code into a mergeable state, merged, and then released. granting of commit bit / admin mode \u00b6 Those with a history of contributing to this project will likely be invited to join the @urfave/cli team. As a member of the @urfave/cli team, you will have the ability to fully administer pull requests, issues, and other repository bits. If you feel that you should be a member of the @urfave/cli team but have not yet been added, the most likely explanation is that this is an accidental oversight! . Please open an issue!","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Welcome to the urfave/cli contributor docs! This goal of this document is to help those interested in joining the 200+ humans who have contributed to this project over the years. As a general guiding principle, the current maintainers may be notified via the @urfave/cli GitHub team. All of the current maintainers are volunteers who live in various timezones with different scheduling needs, so please understand that your contribution or question may not get a response for many days.","title":"Contributing"},{"location":"CONTRIBUTING/#semantic-versioning-adherence","text":"The urfave/cli project strives to strictly adhere to semantic versioning . The active development branches and the milestones and import paths to which they correspond are:","title":"semantic versioning adherence"},{"location":"CONTRIBUTING/#main-branch","text":"https://github.com/urfave/cli/tree/main The majority of active development and issue management is targeting the main branch, which MUST only receive bug fixes and feature additions . v2.x github.com/urfave/cli/v2 The main branch in particular includes tooling to help with keeping the v2.x series backward compatible. More details on this process are in the development workflow section below.","title":"main branch"},{"location":"CONTRIBUTING/#v1-branch","text":"https://github.com/urfave/cli/tree/v1 The v1 branch MUST only receive bug fixes in the v1.22.x series. There is no strict rule regarding bug fixes to the v2.x series being backported to the v1.22.x series. v1.22.x github.com/urfave/cli","title":"v1 branch"},{"location":"CONTRIBUTING/#v3-dev-main-branch","text":"https://github.com/urfave/cli/tree/v3-dev-main The v3-dev-branch MUST receive all bug fixes and features added to the main branch and MAY receive feature removals and other changes that are otherwise backward-incompatible with the v2.x series. v3.x unreleased / unsupported","title":"v3-dev-main branch"},{"location":"CONTRIBUTING/#development-workflow","text":"Most of the tooling around the development workflow strives for effective dogfooding . There is a top-level Makefile that is maintained strictly for the purpose of easing verification of one's development environment and any changes one may have introduced: make Running the default make target ( all ) will ensure all of the critical steps are run to verify one's changes are harmonious in nature. The same steps are also run during the continuous integration phase . In the event that the v2diff target exits non-zero, this is a signal that the public API surface area has changed. If the changes adhere to semantic versioning, meaning they are additions or bug fixes , then manually running the approval step will \"promote\" the current go doc output: make v2approve Because the generate step includes updating godoc-current.txt and testdata/godoc-v2.x.txt , these changes MUST be part of any proposed pull request so that reviewers have an opportunity to also make an informed decision about the \"promotion\" step.","title":"development workflow"},{"location":"CONTRIBUTING/#generated-code","text":"A significant portion of the project's source code is generated, with the goal being to eliminate repetitive maintenance where other type-safe abstraction is impractical or impossible with Go versions < 1.18 . In a future where the eldest Go version supported is 1.18.x , there will likely be efforts to take advantage of generics . The built-in go generate command is used to run the commands specified in //go:generate directives. Each such command runs a file that also supports a command line help system which may be consulted for further information, e.g.: go run cmd/urfave-cli-genflags/main.go --help","title":"generated code"},{"location":"CONTRIBUTING/#docs-output","text":"The documentation in the docs directory is automatically built via mkdocs into a static site and published when releases are pushed (see RELEASING ). There is no strict requirement to build the documentation when developing locally, but the following make targets may be used if desired: # install documentation dependencies with `pip` make ensure-mkdocs # build the static site in `./site` make docs # start an mkdocs development server make serve-docs","title":"docs output"},{"location":"CONTRIBUTING/#pull-requests","text":"Please feel free to open a pull request to fix a bug or add a feature. The @urfave/cli team will review it as soon as possible, giving special attention to maintaining backward compatibility. If the @urfave/cli team agrees that your contribution is in line with the vision of the project, they will work with you to get the code into a mergeable state, merged, and then released.","title":"pull requests"},{"location":"CONTRIBUTING/#granting-of-commit-bit-admin-mode","text":"Those with a history of contributing to this project will likely be invited to join the @urfave/cli team. As a member of the @urfave/cli team, you will have the ability to fully administer pull requests, issues, and other repository bits. If you feel that you should be a member of the @urfave/cli team but have not yet been added, the most likely explanation is that this is an accidental oversight! . Please open an issue!","title":"granting of commit bit / admin mode"},{"location":"RELEASING/","text":"Releasing urfave/cli \u00b6 Releasing small batches often is backed by research as part of the virtuous cycles that keep teams and products healthy. To that end, the overall goal of the release process is to send changes out into the world as close to the time the commits were merged to the main branch as possible. In this way, the community of humans depending on this library are able to make use of the changes they need quickly , which means they shouldn't have to maintain long-lived forks of the project, which means they can get back to focusing on the work on which they want to focus. This also means that the @urfave/cli team should be able to focus on delivering a steadily improving product with significantly eased ability to associate bugs and regressions with specific releases. Process \u00b6 Release versions follow semantic versioning Releases are associated with signed, annotated git tags 1 . Release notes are automatically generated 2 . In the main or v1 branch, the current version is always available via: git describe --always --dirty --tags NOTE : if the version reported contains -dirty , this is indicative of a \"dirty\" work tree, which is not a great state for creating a new release tag. Seek help from @urfave/cli teammates. For example, given a described version of v2.4.7-3-g68da1cd and a diff of v2.4.7... that contains only bug fixes, the next version should be v2.4.8 : git tag -a -s -m 'Release 2.4.8' v2.4.8 git push origin v2.4.8 The tag push will trigger a GitHub Actions workflow and will be immediately available to the Go module mirror, index, and checksum database . The remaining steps require human intervention through the GitHub web view although automated solutions exist that may be adopted in the future. Open the the new release page At the top of the form, click on the Choose a tag select control and select v2.4.8 In the Write tab below, click the Auto-generate release notes button At the bottom of the form, click the Publish release button you're done! This was not always true. There are many lightweight git tags present in the repository history. \u21a9 This was not always true. The docs/CHANGELOG.md document used to be manually maintained. Relying on the automatic release notes generation requires the use of merge commits as opposed to squash merging or rebase merging. \u21a9","title":"Releasing"},{"location":"RELEASING/#releasing-urfavecli","text":"Releasing small batches often is backed by research as part of the virtuous cycles that keep teams and products healthy. To that end, the overall goal of the release process is to send changes out into the world as close to the time the commits were merged to the main branch as possible. In this way, the community of humans depending on this library are able to make use of the changes they need quickly , which means they shouldn't have to maintain long-lived forks of the project, which means they can get back to focusing on the work on which they want to focus. This also means that the @urfave/cli team should be able to focus on delivering a steadily improving product with significantly eased ability to associate bugs and regressions with specific releases.","title":"Releasing urfave/cli"},{"location":"RELEASING/#process","text":"Release versions follow semantic versioning Releases are associated with signed, annotated git tags 1 . Release notes are automatically generated 2 . In the main or v1 branch, the current version is always available via: git describe --always --dirty --tags NOTE : if the version reported contains -dirty , this is indicative of a \"dirty\" work tree, which is not a great state for creating a new release tag. Seek help from @urfave/cli teammates. For example, given a described version of v2.4.7-3-g68da1cd and a diff of v2.4.7... that contains only bug fixes, the next version should be v2.4.8 : git tag -a -s -m 'Release 2.4.8' v2.4.8 git push origin v2.4.8 The tag push will trigger a GitHub Actions workflow and will be immediately available to the Go module mirror, index, and checksum database . The remaining steps require human intervention through the GitHub web view although automated solutions exist that may be adopted in the future. Open the the new release page At the top of the form, click on the Choose a tag select control and select v2.4.8 In the Write tab below, click the Auto-generate release notes button At the bottom of the form, click the Publish release button you're done! This was not always true. There are many lightweight git tags present in the repository history. \u21a9 This was not always true. The docs/CHANGELOG.md document used to be manually maintained. Relying on the automatic release notes generation requires the use of merge commits as opposed to squash merging or rebase merging. \u21a9","title":"Process"},{"location":"SECURITY/","text":"Security Policy \u00b6 Hello and thank you for your interest in the urfave/cli security policy! Supported Versions \u00b6 Version Supported >= v2.3.x < v2.3 >= v1.22.x 1 < v1.22 Reporting a Vulnerability \u00b6 Please disclose any vulnerabilities by sending an email to: urfave-security@googlegroups.com You should expect a response within 48 hours and further communications to be decided via email. The urfave/cli maintainer team comprises volunteers who contribute when possible, so please have patience The v1.22.x series will receive bug fixes and security patches only. \u21a9","title":"Security"},{"location":"SECURITY/#security-policy","text":"Hello and thank you for your interest in the urfave/cli security policy!","title":"Security Policy"},{"location":"SECURITY/#supported-versions","text":"Version Supported >= v2.3.x < v2.3 >= v1.22.x 1 < v1.22","title":"Supported Versions"},{"location":"SECURITY/#reporting-a-vulnerability","text":"Please disclose any vulnerabilities by sending an email to: urfave-security@googlegroups.com You should expect a response within 48 hours and further communications to be decided via email. The urfave/cli maintainer team comprises volunteers who contribute when possible, so please have patience The v1.22.x series will receive bug fixes and security patches only. \u21a9","title":"Reporting a Vulnerability"},{"location":"migrate-v1-to-v2/","text":"Migration Guide: v1 to v2 \u00b6 v2 has a number of breaking changes but converting is relatively straightforward: make the changes documented below then resolve any compiler errors. We hope this will be sufficient for most typical users. If you find any issues not covered by this document, please post a comment on Issue 921 or consider sending a PR to help improve this guide. Flags before args \u00b6 In v2 flags must come before args. This is more POSIX-compliant. You may need to update scripts, user documentation, etc. This will work: cli hello --shout rick This will not: cli hello rick --shout Import string changed \u00b6 OLD: import \"github.com/urfave/cli\" NEW: import \"github.com/urfave/cli/v2\" Check each file for this and make the change. Shell command to find them all: fgrep -rl github.com/urfave/cli * Flag aliases are done differently \u00b6 Change Name: \"foo, f\" to Name: \"foo\", Aliases: []string{\"f\"} OLD: cli . StringFlag { Name : \"config, cfg\" } NEW: cli . StringFlag { Name : \"config\" , Aliases : [] string { \"cfg\" }, } Sadly v2 doesn't warn you if a comma is in the name. (https://github.com/urfave/cli/issues/1103) EnvVar is now a list (EnvVars) \u00b6 Change EnvVar: \"XXXXX\" to EnvVars: []string{\"XXXXX\"} (plural). OLD: cli . StringFlag { EnvVar : \"APP_LANG\" } NEW: cli . StringFlag { EnvVars : [] string { \"APP_LANG\" } } Actions returns errors \u00b6 A command's Action: now returns an error . OLD: Action: func(c *cli.Context) { NEW: Action: func(c *cli.Context) error { Compiler messages you might see: cannot use func literal (type func(*cli.Context)) as type cli.ActionFunc in field value cli.Flag changed \u00b6 cli.Flag is now a list of pointers. What this means to you: If you make a list of flags, add a & in front of each item. cli.BoolFlag, cli.StringFlag, etc. OLD: app . Flags = [] cli . Flag { cli . BoolFlag { NEW: app . Flags = [] cli . Flag { & cli . BoolFlag { Compiler messages you might see: cli.StringFlag does not implement cli.Flag (Apply method has pointer receiver) Commands are now lists of pointers \u00b6 Occurrences of []Command have been changed to []*Command . What this means to you: Look for []cli.Command{} and change it to []*cli.Command{} Example: OLD: var commands = []cli.Command{} NEW: var commands = []*cli.Command{} Compiler messages you might see: cannot convert commands (type []cli.Command) to type cli.CommandsByName cannot use commands (type []cli.Command) as type []*cli.Command in assignment Lists of commands should be pointers \u00b6 If you are building up a list of commands, the individual items should now be pointers. OLD: cli.Command{ NEW: &cli.Command{ Compiler messages you might see: cannot use cli.Command literal (type cli.Command) as type *cli.Command in argument to Appending Commands \u00b6 Appending to a list of commands needs to be changed since the list is now pointers. OLD: commands = append(commands, *c) NEW: commands = append(commands, c) Compiler messages you might see: cannot use c (type *cli.Command) as type cli.Command in append GlobalString, GlobalBool and its likes are deprecated \u00b6 Use simply String instead of GlobalString , Bool instead of GlobalBool BoolTFlag and BoolT are deprecated \u00b6 BoolTFlag was a Bool Flag with its default value set to true and BoolT was used to find any BoolTFlag used locally, so both are deprecated. OLD: cli . BoolTFlag { Name : FlagName , Usage : FlagUsage , EnvVar : \"FLAG_ENV_VAR\" , } * NEW: cli . BoolFlag { Name : FlagName , Value : true , Usage : FlagUsage , EnvVar : \"FLAG_ENV_VAR\" , } &cli.StringSlice{\"\"} replaced with cli.NewStringSlice(\"\") \u00b6 Example: OLD: Value : & cli . StringSlice { \"\" }, * NEW: Value : cli . NewStringSlice ( \"\" ), } Replace deprecated functions \u00b6 cli.NewExitError() is deprecated. Use cli.Exit() instead. ( Staticcheck detects this automatically and recommends replacement code.) Everything else \u00b6 Compile the code and work through any errors. Most should relate to issues listed above. Once it compiles, test the command. Review the output of -h or any help messages to verify they match the intended flags and subcommands. Then test the program itself. If you find any issues not covered by this document please let us know by submitting a comment on Issue 921 so that others can benefit.","title":"Migrate v1 to v2"},{"location":"migrate-v1-to-v2/#migration-guide-v1-to-v2","text":"v2 has a number of breaking changes but converting is relatively straightforward: make the changes documented below then resolve any compiler errors. We hope this will be sufficient for most typical users. If you find any issues not covered by this document, please post a comment on Issue 921 or consider sending a PR to help improve this guide.","title":"Migration Guide: v1 to v2"},{"location":"migrate-v1-to-v2/#flags-before-args","text":"In v2 flags must come before args. This is more POSIX-compliant. You may need to update scripts, user documentation, etc. This will work: cli hello --shout rick This will not: cli hello rick --shout","title":"Flags before args"},{"location":"migrate-v1-to-v2/#import-string-changed","text":"OLD: import \"github.com/urfave/cli\" NEW: import \"github.com/urfave/cli/v2\" Check each file for this and make the change. Shell command to find them all: fgrep -rl github.com/urfave/cli *","title":"Import string changed"},{"location":"migrate-v1-to-v2/#flag-aliases-are-done-differently","text":"Change Name: \"foo, f\" to Name: \"foo\", Aliases: []string{\"f\"} OLD: cli . StringFlag { Name : \"config, cfg\" } NEW: cli . StringFlag { Name : \"config\" , Aliases : [] string { \"cfg\" }, } Sadly v2 doesn't warn you if a comma is in the name. (https://github.com/urfave/cli/issues/1103)","title":"Flag aliases are done differently"},{"location":"migrate-v1-to-v2/#envvar-is-now-a-list-envvars","text":"Change EnvVar: \"XXXXX\" to EnvVars: []string{\"XXXXX\"} (plural). OLD: cli . StringFlag { EnvVar : \"APP_LANG\" } NEW: cli . StringFlag { EnvVars : [] string { \"APP_LANG\" } }","title":"EnvVar is now a list (EnvVars)"},{"location":"migrate-v1-to-v2/#actions-returns-errors","text":"A command's Action: now returns an error . OLD: Action: func(c *cli.Context) { NEW: Action: func(c *cli.Context) error { Compiler messages you might see: cannot use func literal (type func(*cli.Context)) as type cli.ActionFunc in field value","title":"Actions returns errors"},{"location":"migrate-v1-to-v2/#cliflag-changed","text":"cli.Flag is now a list of pointers. What this means to you: If you make a list of flags, add a & in front of each item. cli.BoolFlag, cli.StringFlag, etc. OLD: app . Flags = [] cli . Flag { cli . BoolFlag { NEW: app . Flags = [] cli . Flag { & cli . BoolFlag { Compiler messages you might see: cli.StringFlag does not implement cli.Flag (Apply method has pointer receiver)","title":"cli.Flag changed"},{"location":"migrate-v1-to-v2/#commands-are-now-lists-of-pointers","text":"Occurrences of []Command have been changed to []*Command . What this means to you: Look for []cli.Command{} and change it to []*cli.Command{} Example: OLD: var commands = []cli.Command{} NEW: var commands = []*cli.Command{} Compiler messages you might see: cannot convert commands (type []cli.Command) to type cli.CommandsByName cannot use commands (type []cli.Command) as type []*cli.Command in assignment","title":"Commands are now lists of pointers"},{"location":"migrate-v1-to-v2/#lists-of-commands-should-be-pointers","text":"If you are building up a list of commands, the individual items should now be pointers. OLD: cli.Command{ NEW: &cli.Command{ Compiler messages you might see: cannot use cli.Command literal (type cli.Command) as type *cli.Command in argument to","title":"Lists of commands should be pointers"},{"location":"migrate-v1-to-v2/#appending-commands","text":"Appending to a list of commands needs to be changed since the list is now pointers. OLD: commands = append(commands, *c) NEW: commands = append(commands, c) Compiler messages you might see: cannot use c (type *cli.Command) as type cli.Command in append","title":"Appending Commands"},{"location":"migrate-v1-to-v2/#globalstring-globalbool-and-its-likes-are-deprecated","text":"Use simply String instead of GlobalString , Bool instead of GlobalBool","title":"GlobalString, GlobalBool and its likes are deprecated"},{"location":"migrate-v1-to-v2/#booltflag-and-boolt-are-deprecated","text":"BoolTFlag was a Bool Flag with its default value set to true and BoolT was used to find any BoolTFlag used locally, so both are deprecated. OLD: cli . BoolTFlag { Name : FlagName , Usage : FlagUsage , EnvVar : \"FLAG_ENV_VAR\" , } * NEW: cli . BoolFlag { Name : FlagName , Value : true , Usage : FlagUsage , EnvVar : \"FLAG_ENV_VAR\" , }","title":"BoolTFlag and BoolT are deprecated"},{"location":"migrate-v1-to-v2/#clistringslice-replaced-with-clinewstringslice","text":"Example: OLD: Value : & cli . StringSlice { \"\" }, * NEW: Value : cli . NewStringSlice ( \"\" ), }","title":"&amp;cli.StringSlice{\"\"} replaced with cli.NewStringSlice(\"\")"},{"location":"migrate-v1-to-v2/#replace-deprecated-functions","text":"cli.NewExitError() is deprecated. Use cli.Exit() instead. ( Staticcheck detects this automatically and recommends replacement code.)","title":"Replace deprecated functions"},{"location":"migrate-v1-to-v2/#everything-else","text":"Compile the code and work through any errors. Most should relate to issues listed above. Once it compiles, test the command. Review the output of -h or any help messages to verify they match the intended flags and subcommands. Then test the program itself. If you find any issues not covered by this document please let us know by submitting a comment on Issue 921 so that others can benefit.","title":"Everything else"},{"location":"v1/getting-started/","tags":["v1"],"text":"One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in main() . package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { err := cli . NewApp (). Run ( os . Args ) if err != nil { log . Fatal ( err ) } } This app will run and show help text, but is not very useful. Let's give an action to execute and some help documentation: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Name = \"boom\" app . Usage = \"make an explosive entrance\" app . Action = func ( c * cli . Context ) error { fmt . Println ( \"boom! I say!\" ) return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.","title":"Getting Started"},{"location":"v1/migrating-to-v2/","tags":["v1"],"text":"There are a small set of breaking changes between v1 and v2. Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v1 to v2 .","title":"Migrating to v2"},{"location":"v1/examples/arguments/","tags":["v1"],"text":"You can lookup arguments by calling the Args function on cli.Context , e.g.: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Action = func ( c * cli . Context ) error { fmt . Printf ( \"Hello %q\" , c . Args (). Get ( 0 )) return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Arguments"},{"location":"v1/examples/bash-completions/","tags":["v1"],"text":"You can enable completion commands by setting the EnableBashCompletion flag on the App object. By default, this setting will only auto-complete to show an app's subcommands, but you can write your own completion methods for the App or its subcommands. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { tasks := [] string { \"cook\" , \"clean\" , \"laundry\" , \"eat\" , \"sleep\" , \"code\" } app := cli . NewApp () app . EnableBashCompletion = true app . Commands = [] cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( c * cli . Context ) error { fmt . Println ( \"completed task: \" , c . Args (). First ()) return nil }, BashComplete : func ( c * cli . Context ) { // This will complete if no args are passed if c . NArg () > 0 { return } for _ , t := range tasks { fmt . Println ( t ) } }, }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Enabling \u00b6 Source the autocomplete/bash_autocomplete file in your .bashrc file while setting the PROG variable to the name of your program: PROG=myprogram source /.../cli/autocomplete/bash_autocomplete Distribution \u00b6 Copy autocomplete/bash_autocomplete into /etc/bash_completion.d/ and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file to make it active in the current shell. sudo cp src/bash_autocomplete /etc/bash_completion.d/<myprogram> source /etc/bash_completion.d/<myprogram> Alternatively, you can just document that users should source the generic autocomplete/bash_autocomplete in their bash configuration with $PROG set to the name of their program (as above). Customization \u00b6 The default bash completion flag ( --generate-bash-completion ) is defined as cli.BashCompletionFlag , and may be redefined if desired, e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . BashCompletionFlag = cli . BoolFlag { Name : \"compgen\" , Hidden : true , } app := cli . NewApp () app . EnableBashCompletion = true app . Commands = [] cli . Command { { Name : \"wat\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Bash Completions"},{"location":"v1/examples/bash-completions/#enabling","text":"Source the autocomplete/bash_autocomplete file in your .bashrc file while setting the PROG variable to the name of your program: PROG=myprogram source /.../cli/autocomplete/bash_autocomplete","title":"Enabling"},{"location":"v1/examples/bash-completions/#distribution","text":"Copy autocomplete/bash_autocomplete into /etc/bash_completion.d/ and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file to make it active in the current shell. sudo cp src/bash_autocomplete /etc/bash_completion.d/<myprogram> source /etc/bash_completion.d/<myprogram> Alternatively, you can just document that users should source the generic autocomplete/bash_autocomplete in their bash configuration with $PROG set to the name of their program (as above).","title":"Distribution"},{"location":"v1/examples/bash-completions/#customization","text":"The default bash completion flag ( --generate-bash-completion ) is defined as cli.BashCompletionFlag , and may be redefined if desired, e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . BashCompletionFlag = cli . BoolFlag { Name : \"compgen\" , Hidden : true , } app := cli . NewApp () app . EnableBashCompletion = true app . Commands = [] cli . Command { { Name : \"wat\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Customization"},{"location":"v1/examples/combining-short-options/","tags":["v1"],"text":"Traditional use of options using their shortnames look like this: $ cmd -s -o -m \"Some message\" Suppose you want users to be able to combine options with their shortnames. This can be done using the UseShortOptionHandling bool in your app configuration, or for individual commands by attaching it to the command configuration. For example: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . UseShortOptionHandling = true app . Commands = [] cli . Command { { Name : \"short\" , Usage : \"complete a task on the list\" , Flags : [] cli . Flag { cli . BoolFlag { Name : \"serve, s\" }, cli . BoolFlag { Name : \"option, o\" }, cli . StringFlag { Name : \"message, m\" }, }, Action : func ( c * cli . Context ) error { fmt . Println ( \"serve:\" , c . Bool ( \"serve\" )) fmt . Println ( \"option:\" , c . Bool ( \"option\" )) fmt . Println ( \"message:\" , c . String ( \"message\" )) return nil }, }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } If your program has any number of bool flags such as serve and option , and optionally one non-bool flag message , with the short options of -s , -o , and -m respectively, setting UseShortOptionHandling will also support the following syntax: $ cmd -som \"Some message\" If you enable UseShortOptionHandling , then you must not use any flags that have a single leading - or this will result in failures. For example, -option can no longer be used. Flags with two leading dashes (such as --options ) are still valid.","title":"Combining Short Options"},{"location":"v1/examples/exit-codes/","tags":["v1"],"text":"Calling App.Run will not automatically call os.Exit , which means that by default the exit code will \"fall through\" to being 0 . An explicit exit code may be set by returning a non-nil error that fulfills cli.ExitCoder , or a cli.MultiError that includes an error that fulfills cli.ExitCoder , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . BoolFlag { Name : \"ginger-crouton\" , Usage : \"Add ginger croutons to the soup\" , }, } app . Action = func ( ctx * cli . Context ) error { if ! ctx . Bool ( \"ginger-crouton\" ) { return cli . NewExitError ( \"Ginger croutons are not in the soup\" , 86 ) } return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Exit Codes"},{"location":"v1/examples/flags/","tags":["v1"],"text":"Setting and querying flags is simple. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , }, } app . Action = func ( c * cli . Context ) error { name := \"Nefertiti\" if c . NArg () > 0 { name = c . Args (). Get ( 0 ) } if c . String ( \"lang\" ) == \"spanish\" { fmt . Println ( \"Hola\" , name ) } else { fmt . Println ( \"Hello\" , name ) } return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } You can also set a destination variable for a flag, to which the content will be scanned. package main import ( \"log\" \"os\" \"fmt\" \"github.com/urfave/cli\" ) func main () { var language string app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , Destination : & language , }, } app . Action = func ( c * cli . Context ) error { name := \"someone\" if c . NArg () > 0 { name = c . Args ()[ 0 ] } if language == \"spanish\" { fmt . Println ( \"Hola\" , name ) } else { fmt . Println ( \"Hello\" , name ) } return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } See full list of flags at http://godoc.org/github.com/urfave/cli Placeholder Values \u00b6 Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"config, c\" , Usage : \"Load configuration from `FILE`\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is. Alternate Names \u00b6 You can set alternate (or short) names for flags by providing a comma-delimited list for the Name . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } That flag can then be set with --lang spanish or -l spanish . Note that giving two different forms of the same flag in the same command invocation is an error. Ordering \u00b6 Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using FlagsByName or CommandsByName with sort . For example this: package main import ( \"log\" \"os\" \"sort\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"Language for the greeting\" , }, cli . StringFlag { Name : \"config, c\" , Usage : \"Load configuration from `FILE`\" , }, } app . Commands = [] cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( c * cli . Context ) error { return nil }, }, { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( c * cli . Context ) error { return nil }, }, } sort . Sort ( cli . FlagsByName ( app . Flags )) sort . Sort ( cli . CommandsByName ( app . Commands )) err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE --lang value, -l value Language for the greeting (default: \"english\") Values from the Environment \u00b6 You can also have the default value set from the environment via EnvVar . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , EnvVar : \"APP_LANG\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } The EnvVar may also be given as a comma-delimited \"cascade\", where the first environment variable that resolves is used as the default. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , EnvVar : \"LEGACY_COMPAT_LANG,APP_LANG,LANG\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Values from files \u00b6 You can also have the default value set from file via FilePath . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"password, p\" , Usage : \"password for the mysql database\" , FilePath : \"/etc/mysql/password\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Note that default values set from file (e.g. FilePath ) take precedence over default values set from the environment (e.g. EnvVar ). Values from alternate input sources (YAML, TOML, and others) \u00b6 There is a separate package altsrc that adds support for getting flag values from other file input sources. Currently supported input source formats: * YAML * JSON * TOML In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below: altsrc . NewIntFlag ( cli . IntFlag { Name : \"test\" }) Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below. command . Before = altsrc . InitInputSourceWithContext ( command . Flags , NewYamlSourceFromFlagFunc ( \"load\" )) The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context. It will then use that file name to initialize the yaml input source for any flags that are defined on that command. As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work. Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources. Here is a more complete sample of a command using YAML support: package notmain import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" \"github.com/urfave/cli/altsrc\" ) func main () { app := cli . NewApp () flags := [] cli . Flag { altsrc . NewIntFlag ( cli . IntFlag { Name : \"test\" }), cli . StringFlag { Name : \"load\" }, } app . Action = func ( c * cli . Context ) error { fmt . Println ( \"yaml ist rad\" ) return nil } app . Before = altsrc . InitInputSourceWithContext ( flags , altsrc . NewYamlSourceFromFlagFunc ( \"load\" )) app . Flags = flags err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Precedence \u00b6 The precedence for flag value sources is as follows (highest to lowest): Command line flag value from user Environment variable (if specified) Configuration file (if specified) Default defined on the flag","title":"Flags"},{"location":"v1/examples/flags/#placeholder-values","text":"Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"config, c\" , Usage : \"Load configuration from `FILE`\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.","title":"Placeholder Values"},{"location":"v1/examples/flags/#alternate-names","text":"You can set alternate (or short) names for flags by providing a comma-delimited list for the Name . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } That flag can then be set with --lang spanish or -l spanish . Note that giving two different forms of the same flag in the same command invocation is an error.","title":"Alternate Names"},{"location":"v1/examples/flags/#ordering","text":"Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using FlagsByName or CommandsByName with sort . For example this: package main import ( \"log\" \"os\" \"sort\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"Language for the greeting\" , }, cli . StringFlag { Name : \"config, c\" , Usage : \"Load configuration from `FILE`\" , }, } app . Commands = [] cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( c * cli . Context ) error { return nil }, }, { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( c * cli . Context ) error { return nil }, }, } sort . Sort ( cli . FlagsByName ( app . Flags )) sort . Sort ( cli . CommandsByName ( app . Commands )) err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE --lang value, -l value Language for the greeting (default: \"english\")","title":"Ordering"},{"location":"v1/examples/flags/#values-from-the-environment","text":"You can also have the default value set from the environment via EnvVar . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , EnvVar : \"APP_LANG\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } The EnvVar may also be given as a comma-delimited \"cascade\", where the first environment variable that resolves is used as the default. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"lang, l\" , Value : \"english\" , Usage : \"language for the greeting\" , EnvVar : \"LEGACY_COMPAT_LANG,APP_LANG,LANG\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Values from the Environment"},{"location":"v1/examples/flags/#values-from-files","text":"You can also have the default value set from file via FilePath . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Flags = [] cli . Flag { cli . StringFlag { Name : \"password, p\" , Usage : \"password for the mysql database\" , FilePath : \"/etc/mysql/password\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Note that default values set from file (e.g. FilePath ) take precedence over default values set from the environment (e.g. EnvVar ).","title":"Values from files"},{"location":"v1/examples/flags/#values-from-alternate-input-sources-yaml-toml-and-others","text":"There is a separate package altsrc that adds support for getting flag values from other file input sources. Currently supported input source formats: * YAML * JSON * TOML In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below: altsrc . NewIntFlag ( cli . IntFlag { Name : \"test\" }) Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below. command . Before = altsrc . InitInputSourceWithContext ( command . Flags , NewYamlSourceFromFlagFunc ( \"load\" )) The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context. It will then use that file name to initialize the yaml input source for any flags that are defined on that command. As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work. Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources. Here is a more complete sample of a command using YAML support: package notmain import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" \"github.com/urfave/cli/altsrc\" ) func main () { app := cli . NewApp () flags := [] cli . Flag { altsrc . NewIntFlag ( cli . IntFlag { Name : \"test\" }), cli . StringFlag { Name : \"load\" }, } app . Action = func ( c * cli . Context ) error { fmt . Println ( \"yaml ist rad\" ) return nil } app . Before = altsrc . InitInputSourceWithContext ( flags , altsrc . NewYamlSourceFromFlagFunc ( \"load\" )) app . Flags = flags err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Values from alternate input sources (YAML, TOML, and others)"},{"location":"v1/examples/flags/#precedence","text":"The precedence for flag value sources is as follows (highest to lowest): Command line flag value from user Environment variable (if specified) Configuration file (if specified) Default defined on the flag","title":"Precedence"},{"location":"v1/examples/generated-help-text/","tags":["v1"],"text":"The default help flag ( -h/--help ) is defined as cli.HelpFlag and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution. Customization \u00b6 All of the help text generation may be customized, and at multiple levels. The templates are exposed as variables AppHelpTemplate , CommandHelpTemplate , and SubcommandHelpTemplate which may be reassigned or augmented, and full override is possible by assigning a compatible func to the cli.HelpPrinter variable, e.g.: package main import ( \"fmt\" \"log\" \"io\" \"os\" \"github.com/urfave/cli\" ) func main () { // EXAMPLE: Append to an existing template cli . AppHelpTemplate = fmt . Sprintf ( `%s WEBSITE: http://awesometown.example.com SUPPORT: support@awesometown.example.com ` , cli . AppHelpTemplate ) // EXAMPLE: Override a template cli . AppHelpTemplate = `NAME: {{.Name}} - {{.Usage}} USAGE: {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}} {{if len .Authors}} AUTHOR: {{range .Authors}}{{ . }}{{end}} {{end}}{{if .Commands}} COMMANDS: {{range .Commands}}{{if not .HideHelp}} {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}} GLOBAL OPTIONS: {{range .VisibleFlags}}{{.}} {{end}}{{end}}{{if .Copyright }} COPYRIGHT: {{.Copyright}} {{end}}{{if .Version}} VERSION: {{.Version}} {{end}} ` // EXAMPLE: Replace the `HelpPrinter` func cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Println ( \"Ha HA. I pwnd the help!!1\" ) } err := cli . NewApp (). Run ( os . Args ) if err != nil { log . Fatal ( err ) } } The default flag may be customized to something other than -h/--help by setting cli.HelpFlag , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . HelpFlag = cli . BoolFlag { Name : \"halp, haaaaalp\" , Usage : \"HALP\" , EnvVar : \"SHOW_HALP,HALPPLZ\" , } err := cli . NewApp (). Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Generated Help Text"},{"location":"v1/examples/generated-help-text/#customization","text":"All of the help text generation may be customized, and at multiple levels. The templates are exposed as variables AppHelpTemplate , CommandHelpTemplate , and SubcommandHelpTemplate which may be reassigned or augmented, and full override is possible by assigning a compatible func to the cli.HelpPrinter variable, e.g.: package main import ( \"fmt\" \"log\" \"io\" \"os\" \"github.com/urfave/cli\" ) func main () { // EXAMPLE: Append to an existing template cli . AppHelpTemplate = fmt . Sprintf ( `%s WEBSITE: http://awesometown.example.com SUPPORT: support@awesometown.example.com ` , cli . AppHelpTemplate ) // EXAMPLE: Override a template cli . AppHelpTemplate = `NAME: {{.Name}} - {{.Usage}} USAGE: {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}} {{if len .Authors}} AUTHOR: {{range .Authors}}{{ . }}{{end}} {{end}}{{if .Commands}} COMMANDS: {{range .Commands}}{{if not .HideHelp}} {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}} GLOBAL OPTIONS: {{range .VisibleFlags}}{{.}} {{end}}{{end}}{{if .Copyright }} COPYRIGHT: {{.Copyright}} {{end}}{{if .Version}} VERSION: {{.Version}} {{end}} ` // EXAMPLE: Replace the `HelpPrinter` func cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Println ( \"Ha HA. I pwnd the help!!1\" ) } err := cli . NewApp (). Run ( os . Args ) if err != nil { log . Fatal ( err ) } } The default flag may be customized to something other than -h/--help by setting cli.HelpFlag , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . HelpFlag = cli . BoolFlag { Name : \"halp, haaaaalp\" , Usage : \"HALP\" , EnvVar : \"SHOW_HALP,HALPPLZ\" , } err := cli . NewApp (). Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Customization"},{"location":"v1/examples/greet/","tags":["v1"],"text":"Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness! Start by creating a directory named greet , and within it, add a file, greet.go with the following code in it: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Name = \"greet\" app . Usage = \"fight the loneliness!\" app . Action = func ( c * cli . Context ) error { fmt . Println ( \"Hello friend!\" ) return nil } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Install our command to the $GOPATH/bin directory: $ go install Finally run our new command: $ greet Hello friend! cli also generates neat help text: $ greet help NAME: greet - fight the loneliness! USAGE: greet [global options] command [command options] [arguments...] VERSION: 0.0.0 COMMANDS: help, h Shows a list of commands or help for one command GLOBAL OPTIONS --version Shows version information","title":"Greet"},{"location":"v1/examples/subcommands-categories/","tags":["v1"],"text":"For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output. E.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Commands = [] cli . Command { { Name : \"noop\" , }, { Name : \"add\" , Category : \"Template actions\" , }, { Name : \"remove\" , Category : \"Template actions\" , }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Will include: COMMANDS: noop Template actions: add remove","title":"Subcommands (Categories)"},{"location":"v1/examples/subcommands/","tags":["v1"],"text":"Subcommands can be defined for a more git-like command line app. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { app := cli . NewApp () app . Commands = [] cli . Command { { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( c * cli . Context ) error { fmt . Println ( \"added task: \" , c . Args (). First ()) return nil }, }, { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( c * cli . Context ) error { fmt . Println ( \"completed task: \" , c . Args (). First ()) return nil }, }, { Name : \"template\" , Aliases : [] string { \"t\" }, Usage : \"options for task templates\" , Subcommands : [] cli . Command { { Name : \"add\" , Usage : \"add a new template\" , Action : func ( c * cli . Context ) error { fmt . Println ( \"new task template: \" , c . Args (). First ()) return nil }, }, { Name : \"remove\" , Usage : \"remove an existing template\" , Action : func ( c * cli . Context ) error { fmt . Println ( \"removed task template: \" , c . Args (). First ()) return nil }, }, }, }, } err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Subcommands"},{"location":"v1/examples/version-flag/","tags":["v1"],"text":"The default version flag ( -v/--version ) is defined as cli.VersionFlag , which is checked by the cli internals in order to print the App.Version via cli.VersionPrinter and break execution. Customization \u00b6 The default flag may be customized to something other than -v/--version by setting cli.VersionFlag , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . VersionFlag = cli . BoolFlag { Name : \"print-version, V\" , Usage : \"print only the version\" , } app := cli . NewApp () app . Name = \"partay\" app . Version = \"19.99.0\" err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Alternatively, the version printer at cli.VersionPrinter may be overridden, e.g.: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) var ( Revision = \"fafafaf\" ) func main () { cli . VersionPrinter = func ( c * cli . Context ) { fmt . Printf ( \"version=%s revision=%s\\n\" , c . App . Version , Revision ) } app := cli . NewApp () app . Name = \"partay\" app . Version = \"19.99.0\" err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Full API Example \u00b6 Notice : This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged. package main import ( \"errors\" \"flag\" \"fmt\" \"io\" \"io/ioutil\" \"os\" \"time\" \"github.com/urfave/cli\" ) func init () { cli . AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\" cli . CommandHelpTemplate += \"\\nYMMV\\n\" cli . SubcommandHelpTemplate += \"\\nor something\\n\" cli . HelpFlag = cli . BoolFlag { Name : \"halp\" } cli . BashCompletionFlag = cli . BoolFlag { Name : \"compgen\" , Hidden : true } cli . VersionFlag = cli . BoolFlag { Name : \"print-version, V\" } cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Fprintf ( w , \"best of luck to you\\n\" ) } cli . VersionPrinter = func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"version=%s\\n\" , c . App . Version ) } cli . OsExiter = func ( c int ) { fmt . Fprintf ( cli . ErrWriter , \"refusing to exit %d\\n\" , c ) } cli . ErrWriter = ioutil . Discard cli . FlagStringer = func ( fl cli . Flag ) string { return fmt . Sprintf ( \"\\t\\t%s\" , fl . GetName ()) } } type hexWriter struct {} func ( w * hexWriter ) Write ( p [] byte ) ( int , error ) { for _ , b := range p { fmt . Printf ( \"%x\" , b ) } fmt . Printf ( \"\\n\" ) return len ( p ), nil } type genericType struct { s string } func ( g * genericType ) Set ( value string ) error { g . s = value return nil } func ( g * genericType ) String () string { return g . s } func main () { app := cli . NewApp () app . Name = \"k\u0259n\u02c8tr\u012bv\" app . Version = \"19.99.0\" app . Compiled = time . Now () app . Authors = [] cli . Author { cli . Author { Name : \"Example Human\" , Email : \"human@example.com\" , }, } app . Copyright = \"(c) 1999 Serious Enterprise\" app . HelpName = \"contrive\" app . Usage = \"demonstrate available API\" app . UsageText = \"contrive - demonstrating the available API\" app . ArgsUsage = \"[args and such]\" app . Commands = [] cli . Command { cli . Command { Name : \"doo\" , Aliases : [] string { \"do\" }, Category : \"motion\" , Usage : \"do the doo\" , UsageText : \"doo - does the dooing\" , Description : \"no really, there is a lot of dooing to be done\" , ArgsUsage : \"[arrgh]\" , Flags : [] cli . Flag { cli . BoolFlag { Name : \"forever, forevvarr\" }, }, Subcommands : cli . Commands { cli . Command { Name : \"wop\" , Action : wopAction , }, }, SkipFlagParsing : false , HideHelp : false , Hidden : false , HelpName : \"doo!\" , BashComplete : func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"--better\\n\" ) }, Before : func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"brace for impact\\n\" ) return nil }, After : func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"did we lose anyone?\\n\" ) return nil }, Action : func ( c * cli . Context ) error { c . Command . FullName () c . Command . HasName ( \"wop\" ) c . Command . Names () c . Command . VisibleFlags () fmt . Fprintf ( c . App . Writer , \"dodododododoodododddooooododododooo\\n\" ) if c . Bool ( \"forever\" ) { c . Command . Run ( c ) } return nil }, OnUsageError : func ( c * cli . Context , err error , isSubcommand bool ) error { fmt . Fprintf ( c . App . Writer , \"for shame\\n\" ) return err }, }, } app . Flags = [] cli . Flag { cli . BoolFlag { Name : \"fancy\" }, cli . BoolTFlag { Name : \"fancier\" }, cli . DurationFlag { Name : \"howlong, H\" , Value : time . Second * 3 }, cli . Float64Flag { Name : \"howmuch\" }, cli . GenericFlag { Name : \"wat\" , Value : & genericType {}}, cli . Int64Flag { Name : \"longdistance\" }, cli . Int64SliceFlag { Name : \"intervals\" }, cli . IntFlag { Name : \"distance\" }, cli . IntSliceFlag { Name : \"times\" }, cli . StringFlag { Name : \"dance-move, d\" }, cli . StringSliceFlag { Name : \"names, N\" }, cli . UintFlag { Name : \"age\" }, cli . Uint64Flag { Name : \"bigage\" }, } app . EnableBashCompletion = true app . UseShortOptionHandling = true app . HideHelp = false app . HideVersion = false app . BashComplete = func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\" ) } app . Before = func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"HEEEERE GOES\\n\" ) return nil } app . After = func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"Phew!\\n\" ) return nil } app . CommandNotFound = func ( c * cli . Context , command string ) { fmt . Fprintf ( c . App . Writer , \"Thar be no %q here.\\n\" , command ) } app . OnUsageError = func ( c * cli . Context , err error , isSubcommand bool ) error { if isSubcommand { return err } fmt . Fprintf ( c . App . Writer , \"WRONG: %#v\\n\" , err ) return nil } app . Action = func ( c * cli . Context ) error { cli . DefaultAppComplete ( c ) cli . HandleExitCoder ( errors . New ( \"not an exit coder, though\" )) cli . ShowAppHelp ( c ) cli . ShowCommandCompletions ( c , \"nope\" ) cli . ShowCommandHelp ( c , \"also-nope\" ) cli . ShowCompletions ( c ) cli . ShowSubcommandHelp ( c ) cli . ShowVersion ( c ) categories := c . App . Categories () categories . AddCommand ( \"sounds\" , cli . Command { Name : \"bloop\" , }) for _ , category := range c . App . Categories () { fmt . Fprintf ( c . App . Writer , \"%s\\n\" , category . Name ) fmt . Fprintf ( c . App . Writer , \"%#v\\n\" , category . Commands ) fmt . Fprintf ( c . App . Writer , \"%#v\\n\" , category . VisibleCommands ()) } fmt . Printf ( \"%#v\\n\" , c . App . Command ( \"doo\" )) if c . Bool ( \"infinite\" ) { c . App . Run ([] string { \"app\" , \"doo\" , \"wop\" }) } if c . Bool ( \"forevar\" ) { c . App . RunAsSubcommand ( c ) } c . App . Setup () fmt . Printf ( \"%#v\\n\" , c . App . VisibleCategories ()) fmt . Printf ( \"%#v\\n\" , c . App . VisibleCommands ()) fmt . Printf ( \"%#v\\n\" , c . App . VisibleFlags ()) fmt . Printf ( \"%#v\\n\" , c . Args (). First ()) if len ( c . Args ()) > 0 { fmt . Printf ( \"%#v\\n\" , c . Args ()[ 1 ]) } fmt . Printf ( \"%#v\\n\" , c . Args (). Present ()) fmt . Printf ( \"%#v\\n\" , c . Args (). Tail ()) set := flag . NewFlagSet ( \"contrive\" , 0 ) nc := cli . NewContext ( c . App , set , c ) fmt . Printf ( \"%#v\\n\" , nc . Args ()) fmt . Printf ( \"%#v\\n\" , nc . Bool ( \"nope\" )) fmt . Printf ( \"%#v\\n\" , nc . BoolT ( \"nerp\" )) fmt . Printf ( \"%#v\\n\" , nc . Duration ( \"howlong\" )) fmt . Printf ( \"%#v\\n\" , nc . Float64 ( \"hay\" )) fmt . Printf ( \"%#v\\n\" , nc . Generic ( \"bloop\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64 ( \"bonk\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64Slice ( \"burnks\" )) fmt . Printf ( \"%#v\\n\" , nc . Int ( \"bips\" )) fmt . Printf ( \"%#v\\n\" , nc . IntSlice ( \"blups\" )) fmt . Printf ( \"%#v\\n\" , nc . String ( \"snurt\" )) fmt . Printf ( \"%#v\\n\" , nc . StringSlice ( \"snurkles\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint ( \"flub\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint64 ( \"florb\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalBool ( \"global-nope\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalBoolT ( \"global-nerp\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalDuration ( \"global-howlong\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalFloat64 ( \"global-hay\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalGeneric ( \"global-bloop\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalInt ( \"global-bips\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalIntSlice ( \"global-blups\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalString ( \"global-snurt\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalStringSlice ( \"global-snurkles\" )) fmt . Printf ( \"%#v\\n\" , nc . FlagNames ()) fmt . Printf ( \"%#v\\n\" , nc . GlobalFlagNames ()) fmt . Printf ( \"%#v\\n\" , nc . GlobalIsSet ( \"wat\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalSet ( \"wat\" , \"nope\" )) fmt . Printf ( \"%#v\\n\" , nc . NArg ()) fmt . Printf ( \"%#v\\n\" , nc . NumFlags ()) fmt . Printf ( \"%#v\\n\" , nc . Parent ()) nc . Set ( \"wat\" , \"also-nope\" ) ec := cli . NewExitError ( \"ohwell\" , 86 ) fmt . Fprintf ( c . App . Writer , \"%d\" , ec . ExitCode ()) fmt . Printf ( \"made it!\\n\" ) return nil } if os . Getenv ( \"HEXY\" ) != \"\" { app . Writer = & hexWriter {} app . ErrWriter = & hexWriter {} } app . Metadata = map [ string ] interface {}{ \"layers\" : \"many\" , \"explicable\" : false , \"whatever-values\" : 19.99 , } // ignore error so we don't exit non-zero and break gfmrun README example tests _ = app . Run ( os . Args ) } func wopAction ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \":wave: over here, eh\\n\" ) return nil }","title":"Version Flag"},{"location":"v1/examples/version-flag/#customization","text":"The default flag may be customized to something other than -v/--version by setting cli.VersionFlag , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli\" ) func main () { cli . VersionFlag = cli . BoolFlag { Name : \"print-version, V\" , Usage : \"print only the version\" , } app := cli . NewApp () app . Name = \"partay\" app . Version = \"19.99.0\" err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } } Alternatively, the version printer at cli.VersionPrinter may be overridden, e.g.: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli\" ) var ( Revision = \"fafafaf\" ) func main () { cli . VersionPrinter = func ( c * cli . Context ) { fmt . Printf ( \"version=%s revision=%s\\n\" , c . App . Version , Revision ) } app := cli . NewApp () app . Name = \"partay\" app . Version = \"19.99.0\" err := app . Run ( os . Args ) if err != nil { log . Fatal ( err ) } }","title":"Customization"},{"location":"v1/examples/version-flag/#full-api-example","text":"Notice : This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged. package main import ( \"errors\" \"flag\" \"fmt\" \"io\" \"io/ioutil\" \"os\" \"time\" \"github.com/urfave/cli\" ) func init () { cli . AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\" cli . CommandHelpTemplate += \"\\nYMMV\\n\" cli . SubcommandHelpTemplate += \"\\nor something\\n\" cli . HelpFlag = cli . BoolFlag { Name : \"halp\" } cli . BashCompletionFlag = cli . BoolFlag { Name : \"compgen\" , Hidden : true } cli . VersionFlag = cli . BoolFlag { Name : \"print-version, V\" } cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Fprintf ( w , \"best of luck to you\\n\" ) } cli . VersionPrinter = func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"version=%s\\n\" , c . App . Version ) } cli . OsExiter = func ( c int ) { fmt . Fprintf ( cli . ErrWriter , \"refusing to exit %d\\n\" , c ) } cli . ErrWriter = ioutil . Discard cli . FlagStringer = func ( fl cli . Flag ) string { return fmt . Sprintf ( \"\\t\\t%s\" , fl . GetName ()) } } type hexWriter struct {} func ( w * hexWriter ) Write ( p [] byte ) ( int , error ) { for _ , b := range p { fmt . Printf ( \"%x\" , b ) } fmt . Printf ( \"\\n\" ) return len ( p ), nil } type genericType struct { s string } func ( g * genericType ) Set ( value string ) error { g . s = value return nil } func ( g * genericType ) String () string { return g . s } func main () { app := cli . NewApp () app . Name = \"k\u0259n\u02c8tr\u012bv\" app . Version = \"19.99.0\" app . Compiled = time . Now () app . Authors = [] cli . Author { cli . Author { Name : \"Example Human\" , Email : \"human@example.com\" , }, } app . Copyright = \"(c) 1999 Serious Enterprise\" app . HelpName = \"contrive\" app . Usage = \"demonstrate available API\" app . UsageText = \"contrive - demonstrating the available API\" app . ArgsUsage = \"[args and such]\" app . Commands = [] cli . Command { cli . Command { Name : \"doo\" , Aliases : [] string { \"do\" }, Category : \"motion\" , Usage : \"do the doo\" , UsageText : \"doo - does the dooing\" , Description : \"no really, there is a lot of dooing to be done\" , ArgsUsage : \"[arrgh]\" , Flags : [] cli . Flag { cli . BoolFlag { Name : \"forever, forevvarr\" }, }, Subcommands : cli . Commands { cli . Command { Name : \"wop\" , Action : wopAction , }, }, SkipFlagParsing : false , HideHelp : false , Hidden : false , HelpName : \"doo!\" , BashComplete : func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"--better\\n\" ) }, Before : func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"brace for impact\\n\" ) return nil }, After : func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"did we lose anyone?\\n\" ) return nil }, Action : func ( c * cli . Context ) error { c . Command . FullName () c . Command . HasName ( \"wop\" ) c . Command . Names () c . Command . VisibleFlags () fmt . Fprintf ( c . App . Writer , \"dodododododoodododddooooododododooo\\n\" ) if c . Bool ( \"forever\" ) { c . Command . Run ( c ) } return nil }, OnUsageError : func ( c * cli . Context , err error , isSubcommand bool ) error { fmt . Fprintf ( c . App . Writer , \"for shame\\n\" ) return err }, }, } app . Flags = [] cli . Flag { cli . BoolFlag { Name : \"fancy\" }, cli . BoolTFlag { Name : \"fancier\" }, cli . DurationFlag { Name : \"howlong, H\" , Value : time . Second * 3 }, cli . Float64Flag { Name : \"howmuch\" }, cli . GenericFlag { Name : \"wat\" , Value : & genericType {}}, cli . Int64Flag { Name : \"longdistance\" }, cli . Int64SliceFlag { Name : \"intervals\" }, cli . IntFlag { Name : \"distance\" }, cli . IntSliceFlag { Name : \"times\" }, cli . StringFlag { Name : \"dance-move, d\" }, cli . StringSliceFlag { Name : \"names, N\" }, cli . UintFlag { Name : \"age\" }, cli . Uint64Flag { Name : \"bigage\" }, } app . EnableBashCompletion = true app . UseShortOptionHandling = true app . HideHelp = false app . HideVersion = false app . BashComplete = func ( c * cli . Context ) { fmt . Fprintf ( c . App . Writer , \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\" ) } app . Before = func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"HEEEERE GOES\\n\" ) return nil } app . After = func ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \"Phew!\\n\" ) return nil } app . CommandNotFound = func ( c * cli . Context , command string ) { fmt . Fprintf ( c . App . Writer , \"Thar be no %q here.\\n\" , command ) } app . OnUsageError = func ( c * cli . Context , err error , isSubcommand bool ) error { if isSubcommand { return err } fmt . Fprintf ( c . App . Writer , \"WRONG: %#v\\n\" , err ) return nil } app . Action = func ( c * cli . Context ) error { cli . DefaultAppComplete ( c ) cli . HandleExitCoder ( errors . New ( \"not an exit coder, though\" )) cli . ShowAppHelp ( c ) cli . ShowCommandCompletions ( c , \"nope\" ) cli . ShowCommandHelp ( c , \"also-nope\" ) cli . ShowCompletions ( c ) cli . ShowSubcommandHelp ( c ) cli . ShowVersion ( c ) categories := c . App . Categories () categories . AddCommand ( \"sounds\" , cli . Command { Name : \"bloop\" , }) for _ , category := range c . App . Categories () { fmt . Fprintf ( c . App . Writer , \"%s\\n\" , category . Name ) fmt . Fprintf ( c . App . Writer , \"%#v\\n\" , category . Commands ) fmt . Fprintf ( c . App . Writer , \"%#v\\n\" , category . VisibleCommands ()) } fmt . Printf ( \"%#v\\n\" , c . App . Command ( \"doo\" )) if c . Bool ( \"infinite\" ) { c . App . Run ([] string { \"app\" , \"doo\" , \"wop\" }) } if c . Bool ( \"forevar\" ) { c . App . RunAsSubcommand ( c ) } c . App . Setup () fmt . Printf ( \"%#v\\n\" , c . App . VisibleCategories ()) fmt . Printf ( \"%#v\\n\" , c . App . VisibleCommands ()) fmt . Printf ( \"%#v\\n\" , c . App . VisibleFlags ()) fmt . Printf ( \"%#v\\n\" , c . Args (). First ()) if len ( c . Args ()) > 0 { fmt . Printf ( \"%#v\\n\" , c . Args ()[ 1 ]) } fmt . Printf ( \"%#v\\n\" , c . Args (). Present ()) fmt . Printf ( \"%#v\\n\" , c . Args (). Tail ()) set := flag . NewFlagSet ( \"contrive\" , 0 ) nc := cli . NewContext ( c . App , set , c ) fmt . Printf ( \"%#v\\n\" , nc . Args ()) fmt . Printf ( \"%#v\\n\" , nc . Bool ( \"nope\" )) fmt . Printf ( \"%#v\\n\" , nc . BoolT ( \"nerp\" )) fmt . Printf ( \"%#v\\n\" , nc . Duration ( \"howlong\" )) fmt . Printf ( \"%#v\\n\" , nc . Float64 ( \"hay\" )) fmt . Printf ( \"%#v\\n\" , nc . Generic ( \"bloop\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64 ( \"bonk\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64Slice ( \"burnks\" )) fmt . Printf ( \"%#v\\n\" , nc . Int ( \"bips\" )) fmt . Printf ( \"%#v\\n\" , nc . IntSlice ( \"blups\" )) fmt . Printf ( \"%#v\\n\" , nc . String ( \"snurt\" )) fmt . Printf ( \"%#v\\n\" , nc . StringSlice ( \"snurkles\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint ( \"flub\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint64 ( \"florb\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalBool ( \"global-nope\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalBoolT ( \"global-nerp\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalDuration ( \"global-howlong\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalFloat64 ( \"global-hay\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalGeneric ( \"global-bloop\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalInt ( \"global-bips\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalIntSlice ( \"global-blups\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalString ( \"global-snurt\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalStringSlice ( \"global-snurkles\" )) fmt . Printf ( \"%#v\\n\" , nc . FlagNames ()) fmt . Printf ( \"%#v\\n\" , nc . GlobalFlagNames ()) fmt . Printf ( \"%#v\\n\" , nc . GlobalIsSet ( \"wat\" )) fmt . Printf ( \"%#v\\n\" , nc . GlobalSet ( \"wat\" , \"nope\" )) fmt . Printf ( \"%#v\\n\" , nc . NArg ()) fmt . Printf ( \"%#v\\n\" , nc . NumFlags ()) fmt . Printf ( \"%#v\\n\" , nc . Parent ()) nc . Set ( \"wat\" , \"also-nope\" ) ec := cli . NewExitError ( \"ohwell\" , 86 ) fmt . Fprintf ( c . App . Writer , \"%d\" , ec . ExitCode ()) fmt . Printf ( \"made it!\\n\" ) return nil } if os . Getenv ( \"HEXY\" ) != \"\" { app . Writer = & hexWriter {} app . ErrWriter = & hexWriter {} } app . Metadata = map [ string ] interface {}{ \"layers\" : \"many\" , \"explicable\" : false , \"whatever-values\" : 19.99 , } // ignore error so we don't exit non-zero and break gfmrun README example tests _ = app . Run ( os . Args ) } func wopAction ( c * cli . Context ) error { fmt . Fprintf ( c . App . Writer , \":wave: over here, eh\\n\" ) return nil }","title":"Full API Example"},{"boost":2,"location":"v2/getting-started/","tags":["v2"],"text":"One of the philosophies behind cli is that an API should be playful and full of discovery. So a cli app can be as little as one line of code in main() . package main import ( \"os\" \"github.com/urfave/cli/v2\" ) func main () { ( & cli . App {}). Run ( os . Args ) } This app will run and show help text, but is not very useful. Let's give an action to execute and some help documentation: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Name : \"boom\" , Usage : \"make an explosive entrance\" , Action : func ( * cli . Context ) error { fmt . Println ( \"boom! I say!\" ) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Running this already gives you a ton of functionality, plus support for things like subcommands and flags, which are covered below.","title":"Getting Started"},{"boost":2,"location":"v2/migrating-from-older-releases/","tags":["v2"],"text":"There are a small set of breaking changes between v1 and v2. Converting is relatively straightforward and typically takes less than an hour. Specific steps are included in Migration Guide: v1 to v2 . Also see the pkg.go.dev docs for v2 API documentation.","title":"Migrating From Older Releases"},{"boost":2,"location":"v2/examples/arguments/","tags":["v2"],"text":"You can lookup arguments by calling the Args function on cli.Context , e.g.: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Action : func ( cCtx * cli . Context ) error { fmt . Printf ( \"Hello %q\" , cCtx . Args (). Get ( 0 )) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Arguments"},{"boost":2,"location":"v2/examples/bash-completions/","tags":["v2"],"text":"You can enable completion commands by setting the EnableBashCompletion flag on the App object to true . By default, this setting will allow auto-completion for an app's subcommands, but you can write your own completion methods for the App or its subcommands as well. Default auto-completion \u00b6 package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"added task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"completed task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"template\" , Aliases : [] string { \"t\" }, Usage : \"options for task templates\" , Subcommands : [] * cli . Command { { Name : \"add\" , Usage : \"add a new template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"new task template: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"remove\" , Usage : \"remove an existing template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"removed task template: \" , cCtx . Args (). First ()) return nil }, }, }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Custom auto-completion \u00b6 package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { tasks := [] string { \"cook\" , \"clean\" , \"laundry\" , \"eat\" , \"sleep\" , \"code\" } app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"completed task: \" , cCtx . Args (). First ()) return nil }, BashComplete : func ( cCtx * cli . Context ) { // This will complete if no args are passed if cCtx . NArg () > 0 { return } for _ , t := range tasks { fmt . Println ( t ) } }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Enabling \u00b6 To enable auto-completion for the current shell session, a bash script, autocomplete/bash_autocomplete is included in this repo. To use autocomplete/bash_autocomplete set an environment variable named PROG to the name of your program and then source the autocomplete/bash_autocomplete file. For example, if your cli program is called myprogram : $ PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete Auto-completion is now enabled for the current shell, but will not persist into a new shell. Distribution and Persistent Autocompletion \u00b6 Copy autocomplete/bash_autocomplete into /etc/bash_completion.d/ and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file or restart your shell to activate the auto-completion. $ sudo cp path/to/autocomplete/bash_autocomplete /etc/bash_completion.d/<myprogram> $ source /etc/bash_completion.d/<myprogram> Alternatively, you can just document that users should source the generic autocomplete/bash_autocomplete and set $PROG within their bash configuration file, adding these lines: $ PROG=<myprogram> $ source path/to/cli/autocomplete/bash_autocomplete Keep in mind that if they are enabling auto-completion for more than one program, they will need to set PROG and source autocomplete/bash_autocomplete for each program, like so: $ PROG=<program1> $ source path/to/cli/autocomplete/bash_autocomplete $ PROG=<program2> $ source path/to/cli/autocomplete/bash_autocomplete Customization \u00b6 The default shell completion flag ( --generate-bash-completion ) is defined as cli.EnableBashCompletion , and may be redefined if desired, e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"wat\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } ZSH Support \u00b6 Auto-completion for ZSH is also supported using the autocomplete/zsh_autocomplete file included in this repo. One environment variable is used, PROG . Set PROG to the program name as before, and then source path/to/autocomplete/zsh_autocomplete . Adding the following lines to your ZSH configuration file (usually .zshrc ) will allow the auto-completion to persist across new shells: $ PROG=<myprogram> $ source path/to/autocomplete/zsh_autocomplete ZSH default auto-complete example \u00b6 ZSH custom auto-complete example \u00b6 PowerShell Support \u00b6 Auto-completion for PowerShell is also supported using the autocomplete/powershell_autocomplete.ps1 file included in this repo. Rename the script to <my program>.ps1 and move it anywhere in your file system. The location of script does not matter, only the file name of the script has to match the your program's binary name. To activate it, enter: & path / to / autocomplete /< my program >. ps1 To persist across new shells, open the PowerShell profile (with code $profile or notepad $profile ) and add the line: & path / to / autocomplete /< my program >. ps1","title":"Bash Completions"},{"boost":2,"location":"v2/examples/bash-completions/#default-auto-completion","text":"package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"added task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"completed task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"template\" , Aliases : [] string { \"t\" }, Usage : \"options for task templates\" , Subcommands : [] * cli . Command { { Name : \"add\" , Usage : \"add a new template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"new task template: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"remove\" , Usage : \"remove an existing template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"removed task template: \" , cCtx . Args (). First ()) return nil }, }, }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Default auto-completion"},{"boost":2,"location":"v2/examples/bash-completions/#custom-auto-completion","text":"package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { tasks := [] string { \"cook\" , \"clean\" , \"laundry\" , \"eat\" , \"sleep\" , \"code\" } app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"completed task: \" , cCtx . Args (). First ()) return nil }, BashComplete : func ( cCtx * cli . Context ) { // This will complete if no args are passed if cCtx . NArg () > 0 { return } for _ , t := range tasks { fmt . Println ( t ) } }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Custom auto-completion"},{"boost":2,"location":"v2/examples/bash-completions/#enabling","text":"To enable auto-completion for the current shell session, a bash script, autocomplete/bash_autocomplete is included in this repo. To use autocomplete/bash_autocomplete set an environment variable named PROG to the name of your program and then source the autocomplete/bash_autocomplete file. For example, if your cli program is called myprogram : $ PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete Auto-completion is now enabled for the current shell, but will not persist into a new shell.","title":"Enabling"},{"boost":2,"location":"v2/examples/bash-completions/#distribution-and-persistent-autocompletion","text":"Copy autocomplete/bash_autocomplete into /etc/bash_completion.d/ and rename it to the name of the program you wish to add autocomplete support for (or automatically install it there if you are distributing a package). Don't forget to source the file or restart your shell to activate the auto-completion. $ sudo cp path/to/autocomplete/bash_autocomplete /etc/bash_completion.d/<myprogram> $ source /etc/bash_completion.d/<myprogram> Alternatively, you can just document that users should source the generic autocomplete/bash_autocomplete and set $PROG within their bash configuration file, adding these lines: $ PROG=<myprogram> $ source path/to/cli/autocomplete/bash_autocomplete Keep in mind that if they are enabling auto-completion for more than one program, they will need to set PROG and source autocomplete/bash_autocomplete for each program, like so: $ PROG=<program1> $ source path/to/cli/autocomplete/bash_autocomplete $ PROG=<program2> $ source path/to/cli/autocomplete/bash_autocomplete","title":"Distribution and Persistent Autocompletion"},{"boost":2,"location":"v2/examples/bash-completions/#customization","text":"The default shell completion flag ( --generate-bash-completion ) is defined as cli.EnableBashCompletion , and may be redefined if desired, e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { EnableBashCompletion : true , Commands : [] * cli . Command { { Name : \"wat\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Customization"},{"boost":2,"location":"v2/examples/bash-completions/#zsh-support","text":"Auto-completion for ZSH is also supported using the autocomplete/zsh_autocomplete file included in this repo. One environment variable is used, PROG . Set PROG to the program name as before, and then source path/to/autocomplete/zsh_autocomplete . Adding the following lines to your ZSH configuration file (usually .zshrc ) will allow the auto-completion to persist across new shells: $ PROG=<myprogram> $ source path/to/autocomplete/zsh_autocomplete","title":"ZSH Support"},{"boost":2,"location":"v2/examples/bash-completions/#zsh-default-auto-complete-example","text":"","title":"ZSH default auto-complete example"},{"boost":2,"location":"v2/examples/bash-completions/#zsh-custom-auto-complete-example","text":"","title":"ZSH custom auto-complete example"},{"boost":2,"location":"v2/examples/bash-completions/#powershell-support","text":"Auto-completion for PowerShell is also supported using the autocomplete/powershell_autocomplete.ps1 file included in this repo. Rename the script to <my program>.ps1 and move it anywhere in your file system. The location of script does not matter, only the file name of the script has to match the your program's binary name. To activate it, enter: & path / to / autocomplete /< my program >. ps1 To persist across new shells, open the PowerShell profile (with code $profile or notepad $profile ) and add the line: & path / to / autocomplete /< my program >. ps1","title":"PowerShell Support"},{"boost":2,"location":"v2/examples/combining-short-options/","tags":["v2"],"text":"Traditional use of options using their shortnames look like this: $ cmd -s -o -m \"Some message\" Suppose you want users to be able to combine options with their shortnames. This can be done using the UseShortOptionHandling bool in your app configuration, or for individual commands by attaching it to the command configuration. For example: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { UseShortOptionHandling : true , Commands : [] * cli . Command { { Name : \"short\" , Usage : \"complete a task on the list\" , Flags : [] cli . Flag { & cli . BoolFlag { Name : \"serve\" , Aliases : [] string { \"s\" }}, & cli . BoolFlag { Name : \"option\" , Aliases : [] string { \"o\" }}, & cli . StringFlag { Name : \"message\" , Aliases : [] string { \"m\" }}, }, Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"serve:\" , cCtx . Bool ( \"serve\" )) fmt . Println ( \"option:\" , cCtx . Bool ( \"option\" )) fmt . Println ( \"message:\" , cCtx . String ( \"message\" )) return nil }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } If your program has any number of bool flags such as serve and option , and optionally one non-bool flag message , with the short options of -s , -o , and -m respectively, setting UseShortOptionHandling will also support the following syntax: $ cmd -som \"Some message\" If you enable UseShortOptionHandling , then you must not use any flags that have a single leading - or this will result in failures. For example, -option can no longer be used. Flags with two leading dashes (such as --options ) are still valid.","title":"Combining Short Options"},{"boost":2,"location":"v2/examples/exit-codes/","tags":["v2"],"text":"Calling App.Run will not automatically call os.Exit , which means that by default the exit code will \"fall through\" to being 0 . An explicit exit code may be set by returning a non-nil error that fulfills cli.ExitCoder , or a cli.MultiError that includes an error that fulfills cli.ExitCoder , e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . BoolFlag { Name : \"ginger-crouton\" , Usage : \"is it in the soup?\" , }, }, Action : func ( ctx * cli . Context ) error { if ! ctx . Bool ( \"ginger-crouton\" ) { return cli . Exit ( \"Ginger croutons are not in the soup\" , 86 ) } return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Exit Codes"},{"boost":2,"location":"v2/examples/flags/","tags":["v2"],"text":"Setting and querying flags is simple. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , }, }, Action : func ( cCtx * cli . Context ) error { name := \"Nefertiti\" if cCtx . NArg () > 0 { name = cCtx . Args (). Get ( 0 ) } if cCtx . String ( \"lang\" ) == \"spanish\" { fmt . Println ( \"Hola\" , name ) } else { fmt . Println ( \"Hello\" , name ) } return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } You can also set a destination variable for a flag, to which the content will be scanned. Note that if the Value is set for the flag, it will be shown as default, and destination will be set to this value before parsing flag on the command line. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { var language string app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , Destination : & language , }, }, Action : func ( cCtx * cli . Context ) error { name := \"someone\" if cCtx . NArg () > 0 { name = cCtx . Args (). Get ( 0 ) } if language == \"spanish\" { fmt . Println ( \"Hola\" , name ) } else { fmt . Println ( \"Hello\" , name ) } return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } See full list of flags at https://pkg.go.dev/github.com/urfave/cli/v2 For bool flags you can specify the flag multiple times to get a count(e.g -v -v -v or -vvv) package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { var count int app := & cli . App { Flags : [] cli . Flag { & cli . BoolFlag { Name : \"foo\" , Usage : \"foo greeting\" , Count : & count , }, }, Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"count\" , count ) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Placeholder Values \u00b6 Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"config\" , Aliases : [] string { \"c\" }, Usage : \"Load configuration from `FILE`\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is. Alternate Names \u00b6 You can set alternate (or short) names for flags by providing a comma-delimited list for the Name . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } That flag can then be set with --lang spanish or -l spanish . Note that giving two different forms of the same flag in the same command invocation is an error. Grouping \u00b6 You can associate a category for each flag to group them together in the help output, e.g: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . BoolFlag { Name : \"silent\" , Aliases : [] string { \"s\" }, Usage : \"no messages\" , Category : \"Miscellaneous:\" , }, & cli . BoolFlag { Name : \"perl-regexp\" , Aliases : [] string { \"P\" }, Usage : \"PATTERNS are Perl regular expressions\" , Category : \"Pattern selection:\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: GLOBAL OPTIONS: Miscellaneous: --silent, -s no messages (default: false) Pattern selection: --perl-regexp, -P PATTERNS are Perl regular expressions (default: false) Ordering \u00b6 Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using FlagsByName or CommandsByName with sort . For example this: package main import ( \"log\" \"os\" \"sort\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"Language for the greeting\" , }, & cli . StringFlag { Name : \"config\" , Aliases : [] string { \"c\" }, Usage : \"Load configuration from `FILE`\" , }, }, Commands : [] * cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( * cli . Context ) error { return nil }, }, { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( * cli . Context ) error { return nil }, }, }, } sort . Sort ( cli . FlagsByName ( app . Flags )) sort . Sort ( cli . CommandsByName ( app . Commands )) if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE --lang value, -l value Language for the greeting (default: \"english\") Values from the Environment \u00b6 You can also have the default value set from the environment via EnvVars . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , EnvVars : [] string { \"APP_LANG\" }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } If EnvVars contains more than one string, the first environment variable that resolves is used. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , EnvVars : [] string { \"LEGACY_COMPAT_LANG\" , \"APP_LANG\" , \"LANG\" }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Values from files \u00b6 You can also have the default value set from file via FilePath . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"password\" , Aliases : [] string { \"p\" }, Usage : \"password for the mysql database\" , FilePath : \"/etc/mysql/password\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Note that default values set from file (e.g. FilePath ) take precedence over default values set from the environment (e.g. EnvVar ). Values from alternate input sources (YAML, TOML, and others) \u00b6 There is a separate package altsrc that adds support for getting flag values from other file input sources. Currently supported input source formats: YAML JSON TOML In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below: // --- >8 --- altsrc . NewIntFlag ( & cli . IntFlag { Name : \"test\" }) Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below. // --- >8 --- command . Before = altsrc . InitInputSourceWithContext ( command . Flags , NewYamlSourceFromFlagFunc ( \"load\" )) The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context. It will then use that file name to initialize the yaml input source for any flags that are defined on that command. As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work. Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources. Here is a more complete sample of a command using YAML support: package main import ( \"fmt\" \"os\" \"github.com/urfave/cli/v2\" \"github.com/urfave/cli/v2/altsrc\" ) func main () { flags := [] cli . Flag { altsrc . NewIntFlag ( & cli . IntFlag { Name : \"test\" }), & cli . StringFlag { Name : \"load\" }, } app := & cli . App { Action : func ( * cli . Context ) error { fmt . Println ( \"--test value.*default: 0\" ) return nil }, Before : altsrc . InitInputSourceWithContext ( flags , altsrc . NewYamlSourceFromFlagFunc ( \"load\" )), Flags : flags , } app . Run ( os . Args ) } Required Flags \u00b6 You can make a flag required by setting the Required field to true . If a user does not provide a required flag, they will be shown an error message. Take for example this app that requires the lang flag: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , Required : true , }, }, Action : func ( cCtx * cli . Context ) error { output := \"Hello\" if cCtx . String ( \"lang\" ) == \"spanish\" { output = \"Hola\" } fmt . Println ( output ) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } If the app is run without the lang flag, the user will see the following message Required flag \"lang\" not set Default Values for help output \u00b6 Sometimes it's useful to specify a flag's default help-text value within the flag declaration. This can be useful if the default value for a flag is a computed value. The default value can be set via the DefaultText struct field. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . IntFlag { Name : \"port\" , Usage : \"Use a randomized port\" , Value : 0 , DefaultText : \"random\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --port value Use a randomized port (default: random) Precedence \u00b6 The precedence for flag value sources is as follows (highest to lowest): Command line flag value from user Environment variable (if specified) Configuration file (if specified) Default defined on the flag Flag Actions \u00b6 Handlers can be registered per flag which are triggered after a flag has been processed. This can be used for a variety of purposes, one of which is flag validation package main import ( \"log\" \"os\" \"fmt\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . IntFlag { Name : \"port\" , Usage : \"Use a randomized port\" , Value : 0 , DefaultText : \"random\" , Action : func ( ctx * cli . Context , v int ) error { if v >= 65536 { return fmt . Errorf ( \"Flag port value %v out of range[0-65535]\" , v ) } return nil }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: Flag port value 70000 out of range[0-65535]","title":"Flags"},{"boost":2,"location":"v2/examples/flags/#placeholder-values","text":"Sometimes it's useful to specify a flag's value within the usage string itself. Such placeholders are indicated with back quotes. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"config\" , Aliases : [] string { \"c\" }, Usage : \"Load configuration from `FILE`\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE Note that only the first placeholder is used. Subsequent back-quoted words will be left as-is.","title":"Placeholder Values"},{"boost":2,"location":"v2/examples/flags/#alternate-names","text":"You can set alternate (or short) names for flags by providing a comma-delimited list for the Name . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } That flag can then be set with --lang spanish or -l spanish . Note that giving two different forms of the same flag in the same command invocation is an error.","title":"Alternate Names"},{"boost":2,"location":"v2/examples/flags/#grouping","text":"You can associate a category for each flag to group them together in the help output, e.g: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . BoolFlag { Name : \"silent\" , Aliases : [] string { \"s\" }, Usage : \"no messages\" , Category : \"Miscellaneous:\" , }, & cli . BoolFlag { Name : \"perl-regexp\" , Aliases : [] string { \"P\" }, Usage : \"PATTERNS are Perl regular expressions\" , Category : \"Pattern selection:\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: GLOBAL OPTIONS: Miscellaneous: --silent, -s no messages (default: false) Pattern selection: --perl-regexp, -P PATTERNS are Perl regular expressions (default: false)","title":"Grouping"},{"boost":2,"location":"v2/examples/flags/#ordering","text":"Flags for the application and commands are shown in the order they are defined. However, it's possible to sort them from outside this library by using FlagsByName or CommandsByName with sort . For example this: package main import ( \"log\" \"os\" \"sort\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"Language for the greeting\" , }, & cli . StringFlag { Name : \"config\" , Aliases : [] string { \"c\" }, Usage : \"Load configuration from `FILE`\" , }, }, Commands : [] * cli . Command { { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( * cli . Context ) error { return nil }, }, { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( * cli . Context ) error { return nil }, }, }, } sort . Sort ( cli . FlagsByName ( app . Flags )) sort . Sort ( cli . CommandsByName ( app . Commands )) if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --config FILE, -c FILE Load configuration from FILE --lang value, -l value Language for the greeting (default: \"english\")","title":"Ordering"},{"boost":2,"location":"v2/examples/flags/#values-from-the-environment","text":"You can also have the default value set from the environment via EnvVars . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , EnvVars : [] string { \"APP_LANG\" }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } If EnvVars contains more than one string, the first environment variable that resolves is used. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Aliases : [] string { \"l\" }, Value : \"english\" , Usage : \"language for the greeting\" , EnvVars : [] string { \"LEGACY_COMPAT_LANG\" , \"APP_LANG\" , \"LANG\" }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Values from the Environment"},{"boost":2,"location":"v2/examples/flags/#values-from-files","text":"You can also have the default value set from file via FilePath . e.g. package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"password\" , Aliases : [] string { \"p\" }, Usage : \"password for the mysql database\" , FilePath : \"/etc/mysql/password\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Note that default values set from file (e.g. FilePath ) take precedence over default values set from the environment (e.g. EnvVar ).","title":"Values from files"},{"boost":2,"location":"v2/examples/flags/#values-from-alternate-input-sources-yaml-toml-and-others","text":"There is a separate package altsrc that adds support for getting flag values from other file input sources. Currently supported input source formats: YAML JSON TOML In order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below: // --- >8 --- altsrc . NewIntFlag ( & cli . IntFlag { Name : \"test\" }) Initialization must also occur for these flags. Below is an example initializing getting data from a yaml file below. // --- >8 --- command . Before = altsrc . InitInputSourceWithContext ( command . Flags , NewYamlSourceFromFlagFunc ( \"load\" )) The code above will use the \"load\" string as a flag name to get the file name of a yaml file from the cli.Context. It will then use that file name to initialize the yaml input source for any flags that are defined on that command. As a note the \"load\" flag used would also have to be defined on the command flags in order for this code snippet to work. Currently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources. Here is a more complete sample of a command using YAML support: package main import ( \"fmt\" \"os\" \"github.com/urfave/cli/v2\" \"github.com/urfave/cli/v2/altsrc\" ) func main () { flags := [] cli . Flag { altsrc . NewIntFlag ( & cli . IntFlag { Name : \"test\" }), & cli . StringFlag { Name : \"load\" }, } app := & cli . App { Action : func ( * cli . Context ) error { fmt . Println ( \"--test value.*default: 0\" ) return nil }, Before : altsrc . InitInputSourceWithContext ( flags , altsrc . NewYamlSourceFromFlagFunc ( \"load\" )), Flags : flags , } app . Run ( os . Args ) }","title":"Values from alternate input sources (YAML, TOML, and others)"},{"boost":2,"location":"v2/examples/flags/#required-flags","text":"You can make a flag required by setting the Required field to true . If a user does not provide a required flag, they will be shown an error message. Take for example this app that requires the lang flag: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . StringFlag { Name : \"lang\" , Value : \"english\" , Usage : \"language for the greeting\" , Required : true , }, }, Action : func ( cCtx * cli . Context ) error { output := \"Hello\" if cCtx . String ( \"lang\" ) == \"spanish\" { output = \"Hola\" } fmt . Println ( output ) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } If the app is run without the lang flag, the user will see the following message Required flag \"lang\" not set","title":"Required Flags"},{"boost":2,"location":"v2/examples/flags/#default-values-for-help-output","text":"Sometimes it's useful to specify a flag's default help-text value within the flag declaration. This can be useful if the default value for a flag is a computed value. The default value can be set via the DefaultText struct field. For example this: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . IntFlag { Name : \"port\" , Usage : \"Use a randomized port\" , Value : 0 , DefaultText : \"random\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: --port value Use a randomized port (default: random)","title":"Default Values for help output"},{"boost":2,"location":"v2/examples/flags/#precedence","text":"The precedence for flag value sources is as follows (highest to lowest): Command line flag value from user Environment variable (if specified) Configuration file (if specified) Default defined on the flag","title":"Precedence"},{"boost":2,"location":"v2/examples/flags/#flag-actions","text":"Handlers can be registered per flag which are triggered after a flag has been processed. This can be used for a variety of purposes, one of which is flag validation package main import ( \"log\" \"os\" \"fmt\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . IntFlag { Name : \"port\" , Usage : \"Use a randomized port\" , Value : 0 , DefaultText : \"random\" , Action : func ( ctx * cli . Context , v int ) error { if v >= 65536 { return fmt . Errorf ( \"Flag port value %v out of range[0-65535]\" , v ) } return nil }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will result in help output like: Flag port value 70000 out of range[0-65535]","title":"Flag Actions"},{"boost":2,"location":"v2/examples/full-api-example/","tags":["v2"],"text":"Notice : This is a contrived (functioning) example meant strictly for API demonstration purposes. Use of one's imagination is encouraged. package main import ( \"errors\" \"flag\" \"fmt\" \"io\" \"io/ioutil\" \"os\" \"time\" \"github.com/urfave/cli/v2\" ) func init () { cli . AppHelpTemplate += \"\\nCUSTOMIZED: you bet ur muffins\\n\" cli . CommandHelpTemplate += \"\\nYMMV\\n\" cli . SubcommandHelpTemplate += \"\\nor something\\n\" cli . HelpFlag = & cli . BoolFlag { Name : \"halp\" } cli . VersionFlag = & cli . BoolFlag { Name : \"print-version\" , Aliases : [] string { \"V\" }} cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Fprintf ( w , \"best of luck to you\\n\" ) } cli . VersionPrinter = func ( cCtx * cli . Context ) { fmt . Fprintf ( cCtx . App . Writer , \"version=%s\\n\" , cCtx . App . Version ) } cli . OsExiter = func ( cCtx int ) { fmt . Fprintf ( cli . ErrWriter , \"refusing to exit %d\\n\" , cCtx ) } cli . ErrWriter = ioutil . Discard cli . FlagStringer = func ( fl cli . Flag ) string { return fmt . Sprintf ( \"\\t\\t%s\" , fl . Names ()[ 0 ]) } } type hexWriter struct {} func ( w * hexWriter ) Write ( p [] byte ) ( int , error ) { for _ , b := range p { fmt . Printf ( \"%x\" , b ) } fmt . Printf ( \"\\n\" ) return len ( p ), nil } type genericType struct { s string } func ( g * genericType ) Set ( value string ) error { g . s = value return nil } func ( g * genericType ) String () string { return g . s } func main () { app := & cli . App { Name : \"k\u0259n\u02c8tr\u012bv\" , Version : \"v19.99.0\" , Compiled : time . Now (), Authors : [] * cli . Author { & cli . Author { Name : \"Example Human\" , Email : \"human@example.com\" , }, }, Copyright : \"(c) 1999 Serious Enterprise\" , HelpName : \"contrive\" , Usage : \"demonstrate available API\" , UsageText : \"contrive - demonstrating the available API\" , ArgsUsage : \"[args and such]\" , Commands : [] * cli . Command { & cli . Command { Name : \"doo\" , Aliases : [] string { \"do\" }, Category : \"motion\" , Usage : \"do the doo\" , UsageText : \"doo - does the dooing\" , Description : \"no really, there is a lot of dooing to be done\" , ArgsUsage : \"[arrgh]\" , Flags : [] cli . Flag { & cli . BoolFlag { Name : \"forever\" , Aliases : [] string { \"forevvarr\" }}, }, Subcommands : [] * cli . Command { & cli . Command { Name : \"wop\" , Action : wopAction , }, }, SkipFlagParsing : false , HideHelp : false , Hidden : false , HelpName : \"doo!\" , BashComplete : func ( cCtx * cli . Context ) { fmt . Fprintf ( cCtx . App . Writer , \"--better\\n\" ) }, Before : func ( cCtx * cli . Context ) error { fmt . Fprintf ( cCtx . App . Writer , \"brace for impact\\n\" ) return nil }, After : func ( cCtx * cli . Context ) error { fmt . Fprintf ( cCtx . App . Writer , \"did we lose anyone?\\n\" ) return nil }, Action : func ( cCtx * cli . Context ) error { cCtx . Command . FullName () cCtx . Command . HasName ( \"wop\" ) cCtx . Command . Names () cCtx . Command . VisibleFlags () fmt . Fprintf ( cCtx . App . Writer , \"dodododododoodododddooooododododooo\\n\" ) if cCtx . Bool ( \"forever\" ) { cCtx . Command . Run ( cCtx ) } return nil }, OnUsageError : func ( cCtx * cli . Context , err error , isSubcommand bool ) error { fmt . Fprintf ( cCtx . App . Writer , \"for shame\\n\" ) return err }, }, }, Flags : [] cli . Flag { & cli . BoolFlag { Name : \"fancy\" }, & cli . BoolFlag { Value : true , Name : \"fancier\" }, & cli . DurationFlag { Name : \"howlong\" , Aliases : [] string { \"H\" }, Value : time . Second * 3 }, & cli . Float64Flag { Name : \"howmuch\" }, & cli . GenericFlag { Name : \"wat\" , Value : & genericType {}}, & cli . Int64Flag { Name : \"longdistance\" }, & cli . Int64SliceFlag { Name : \"intervals\" }, & cli . IntFlag { Name : \"distance\" }, & cli . IntSliceFlag { Name : \"times\" }, & cli . StringFlag { Name : \"dance-move\" , Aliases : [] string { \"d\" }}, & cli . StringSliceFlag { Name : \"names\" , Aliases : [] string { \"N\" }}, & cli . UintFlag { Name : \"age\" }, & cli . Uint64Flag { Name : \"bigage\" }, }, EnableBashCompletion : true , HideHelp : false , HideVersion : false , BashComplete : func ( cCtx * cli . Context ) { fmt . Fprintf ( cCtx . App . Writer , \"lipstick\\nkiss\\nme\\nlipstick\\nringo\\n\" ) }, Before : func ( cCtx * cli . Context ) error { fmt . Fprintf ( cCtx . App . Writer , \"HEEEERE GOES\\n\" ) return nil }, After : func ( cCtx * cli . Context ) error { fmt . Fprintf ( cCtx . App . Writer , \"Phew!\\n\" ) return nil }, CommandNotFound : func ( cCtx * cli . Context , command string ) { fmt . Fprintf ( cCtx . App . Writer , \"Thar be no %q here.\\n\" , command ) }, OnUsageError : func ( cCtx * cli . Context , err error , isSubcommand bool ) error { if isSubcommand { return err } fmt . Fprintf ( cCtx . App . Writer , \"WRONG: %#v\\n\" , err ) return nil }, Action : func ( cCtx * cli . Context ) error { cli . DefaultAppComplete ( cCtx ) cli . HandleExitCoder ( errors . New ( \"not an exit coder, though\" )) cli . ShowAppHelp ( cCtx ) cli . ShowCommandCompletions ( cCtx , \"nope\" ) cli . ShowCommandHelp ( cCtx , \"also-nope\" ) cli . ShowCompletions ( cCtx ) cli . ShowSubcommandHelp ( cCtx ) cli . ShowVersion ( cCtx ) fmt . Printf ( \"%#v\\n\" , cCtx . App . Command ( \"doo\" )) if cCtx . Bool ( \"infinite\" ) { cCtx . App . Run ([] string { \"app\" , \"doo\" , \"wop\" }) } if cCtx . Bool ( \"forevar\" ) { cCtx . App . RunAsSubcommand ( cCtx ) } cCtx . App . Setup () fmt . Printf ( \"%#v\\n\" , cCtx . App . VisibleCategories ()) fmt . Printf ( \"%#v\\n\" , cCtx . App . VisibleCommands ()) fmt . Printf ( \"%#v\\n\" , cCtx . App . VisibleFlags ()) fmt . Printf ( \"%#v\\n\" , cCtx . Args (). First ()) if cCtx . Args (). Len () > 0 { fmt . Printf ( \"%#v\\n\" , cCtx . Args (). Get ( 1 )) } fmt . Printf ( \"%#v\\n\" , cCtx . Args (). Present ()) fmt . Printf ( \"%#v\\n\" , cCtx . Args (). Tail ()) set := flag . NewFlagSet ( \"contrive\" , 0 ) nc := cli . NewContext ( cCtx . App , set , cCtx ) fmt . Printf ( \"%#v\\n\" , nc . Args ()) fmt . Printf ( \"%#v\\n\" , nc . Bool ( \"nope\" )) fmt . Printf ( \"%#v\\n\" , ! nc . Bool ( \"nerp\" )) fmt . Printf ( \"%#v\\n\" , nc . Duration ( \"howlong\" )) fmt . Printf ( \"%#v\\n\" , nc . Float64 ( \"hay\" )) fmt . Printf ( \"%#v\\n\" , nc . Generic ( \"bloop\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64 ( \"bonk\" )) fmt . Printf ( \"%#v\\n\" , nc . Int64Slice ( \"burnks\" )) fmt . Printf ( \"%#v\\n\" , nc . Int ( \"bips\" )) fmt . Printf ( \"%#v\\n\" , nc . IntSlice ( \"blups\" )) fmt . Printf ( \"%#v\\n\" , nc . String ( \"snurt\" )) fmt . Printf ( \"%#v\\n\" , nc . StringSlice ( \"snurkles\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint ( \"flub\" )) fmt . Printf ( \"%#v\\n\" , nc . Uint64 ( \"florb\" )) fmt . Printf ( \"%#v\\n\" , nc . FlagNames ()) fmt . Printf ( \"%#v\\n\" , nc . IsSet ( \"wat\" )) fmt . Printf ( \"%#v\\n\" , nc . Set ( \"wat\" , \"nope\" )) fmt . Printf ( \"%#v\\n\" , nc . NArg ()) fmt . Printf ( \"%#v\\n\" , nc . NumFlags ()) fmt . Printf ( \"%#v\\n\" , nc . Lineage ()[ 1 ]) nc . Set ( \"wat\" , \"also-nope\" ) ec := cli . Exit ( \"ohwell\" , 86 ) fmt . Fprintf ( cCtx . App . Writer , \"%d\" , ec . ExitCode ()) fmt . Printf ( \"made it!\\n\" ) return ec }, Metadata : map [ string ] interface {}{ \"layers\" : \"many\" , \"explicable\" : false , \"whatever-values\" : 19.99 , }, } if os . Getenv ( \"HEXY\" ) != \"\" { app . Writer = & hexWriter {} app . ErrWriter = & hexWriter {} } app . Run ( os . Args ) } func wopAction ( cCtx * cli . Context ) error { fmt . Fprintf ( cCtx . App . Writer , \":wave: over here, eh\\n\" ) return nil }","title":"Full API Example"},{"boost":2,"location":"v2/examples/generated-help-text/","tags":["v2"],"text":"The default help flag ( -h/--help ) is defined as cli.HelpFlag and is checked by the cli internals in order to print generated help text for the app, command, or subcommand, and break execution. Customization \u00b6 All of the help text generation may be customized, and at multiple levels. The templates are exposed as variables AppHelpTemplate , CommandHelpTemplate , and SubcommandHelpTemplate which may be reassigned or augmented, and full override is possible by assigning a compatible func to the cli.HelpPrinter variable, e.g.: package main import ( \"fmt\" \"io\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { // EXAMPLE: Append to an existing template cli . AppHelpTemplate = fmt . Sprintf ( `%s WEBSITE: http://awesometown.example.com SUPPORT: support@awesometown.example.com ` , cli . AppHelpTemplate ) // EXAMPLE: Override a template cli . AppHelpTemplate = `NAME: {{.Name}} - {{.Usage}} USAGE: {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}} {{if len .Authors}} AUTHOR: {{range .Authors}}{{ . }}{{end}} {{end}}{{if .Commands}} COMMANDS: {{range .Commands}}{{if not .HideHelp}} {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}} GLOBAL OPTIONS: {{range .VisibleFlags}}{{.}} {{end}}{{end}}{{if .Copyright }} COPYRIGHT: {{.Copyright}} {{end}}{{if .Version}} VERSION: {{.Version}} {{end}} ` // EXAMPLE: Replace the `HelpPrinter` func cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Println ( \"Ha HA. I pwnd the help!!1\" ) } ( & cli . App {}). Run ( os . Args ) } The default flag may be customized to something other than -h/--help by setting cli.HelpFlag , e.g.: package main import ( \"os\" \"github.com/urfave/cli/v2\" ) func main () { cli . HelpFlag = & cli . BoolFlag { Name : \"haaaaalp\" , Aliases : [] string { \"halp\" }, Usage : \"HALP\" , EnvVars : [] string { \"SHOW_HALP\" , \"HALPPLZ\" }, } ( & cli . App {}). Run ( os . Args ) }","title":"Generated Help Text"},{"boost":2,"location":"v2/examples/generated-help-text/#customization","text":"All of the help text generation may be customized, and at multiple levels. The templates are exposed as variables AppHelpTemplate , CommandHelpTemplate , and SubcommandHelpTemplate which may be reassigned or augmented, and full override is possible by assigning a compatible func to the cli.HelpPrinter variable, e.g.: package main import ( \"fmt\" \"io\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { // EXAMPLE: Append to an existing template cli . AppHelpTemplate = fmt . Sprintf ( `%s WEBSITE: http://awesometown.example.com SUPPORT: support@awesometown.example.com ` , cli . AppHelpTemplate ) // EXAMPLE: Override a template cli . AppHelpTemplate = `NAME: {{.Name}} - {{.Usage}} USAGE: {{.HelpName}} {{if .VisibleFlags}}[global options]{{end}}{{if .Commands}} command [command options]{{end}} {{if .ArgsUsage}}{{.ArgsUsage}}{{else}}[arguments...]{{end}} {{if len .Authors}} AUTHOR: {{range .Authors}}{{ . }}{{end}} {{end}}{{if .Commands}} COMMANDS: {{range .Commands}}{{if not .HideHelp}} {{join .Names \", \"}}{{ \"\\t\"}}{{.Usage}}{{ \"\\n\" }}{{end}}{{end}}{{end}}{{if .VisibleFlags}} GLOBAL OPTIONS: {{range .VisibleFlags}}{{.}} {{end}}{{end}}{{if .Copyright }} COPYRIGHT: {{.Copyright}} {{end}}{{if .Version}} VERSION: {{.Version}} {{end}} ` // EXAMPLE: Replace the `HelpPrinter` func cli . HelpPrinter = func ( w io . Writer , templ string , data interface {}) { fmt . Println ( \"Ha HA. I pwnd the help!!1\" ) } ( & cli . App {}). Run ( os . Args ) } The default flag may be customized to something other than -h/--help by setting cli.HelpFlag , e.g.: package main import ( \"os\" \"github.com/urfave/cli/v2\" ) func main () { cli . HelpFlag = & cli . BoolFlag { Name : \"haaaaalp\" , Aliases : [] string { \"halp\" }, Usage : \"HALP\" , EnvVars : [] string { \"SHOW_HALP\" , \"HALPPLZ\" }, } ( & cli . App {}). Run ( os . Args ) }","title":"Customization"},{"boost":2,"location":"v2/examples/greet/","tags":["v2"],"text":"Being a programmer can be a lonely job. Thankfully by the power of automation that is not the case! Let's create a greeter app to fend off our demons of loneliness! Start by creating a directory named greet , and within it, add a file, greet.go with the following code in it: package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Name : \"greet\" , Usage : \"fight the loneliness!\" , Action : func ( * cli . Context ) error { fmt . Println ( \"Hello friend!\" ) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Install our command to the $GOPATH/bin directory: $ go install Finally run our new command: $ greet Hello friend! cli also generates neat help text: $ greet help NAME: greet - fight the loneliness! USAGE: greet [global options] command [command options] [arguments...] COMMANDS: help, h Shows a list of commands or help for one command GLOBAL OPTIONS --help, -h show help (default: false)","title":"Greet"},{"boost":2,"location":"v2/examples/subcommands-categories/","tags":["v2"],"text":"For additional organization in apps that have many subcommands, you can associate a category for each command to group them together in the help output, e.g.: package main import ( \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Commands : [] * cli . Command { { Name : \"noop\" , }, { Name : \"add\" , Category : \"template\" , }, { Name : \"remove\" , Category : \"template\" , }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } Will include: COMMANDS: noop template: add remove","title":"Subcommands Categories"},{"boost":2,"location":"v2/examples/subcommands/","tags":["v2"],"text":"Subcommands can be defined for a more git-like command line app. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Commands : [] * cli . Command { { Name : \"add\" , Aliases : [] string { \"a\" }, Usage : \"add a task to the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"added task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"complete\" , Aliases : [] string { \"c\" }, Usage : \"complete a task on the list\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"completed task: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"template\" , Aliases : [] string { \"t\" }, Usage : \"options for task templates\" , Subcommands : [] * cli . Command { { Name : \"add\" , Usage : \"add a new template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"new task template: \" , cCtx . Args (). First ()) return nil }, }, { Name : \"remove\" , Usage : \"remove an existing template\" , Action : func ( cCtx * cli . Context ) error { fmt . Println ( \"removed task template: \" , cCtx . Args (). First ()) return nil }, }, }, }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } }","title":"Subcommands"},{"boost":2,"location":"v2/examples/suggestions/","tags":["v2"],"text":"To enable flag and command suggestions, set app.Suggest = true . If the suggest feature is enabled, then the help output of the corresponding command will provide an appropriate suggestion for the provided flag or subcommand if available.","title":"Suggestions"},{"boost":2,"location":"v2/examples/timestamp-flag/","tags":["v2"],"text":"Using the timestamp flag is simple. Please refer to time.Parse to get possible formats. package main import ( \"fmt\" \"log\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . TimestampFlag { Name : \"meeting\" , Layout : \"2006-01-02T15:04:05\" }, }, Action : func ( cCtx * cli . Context ) error { fmt . Printf ( \"%s\" , cCtx . Timestamp ( \"meeting\" ). String ()) return nil }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } In this example the flag could be used like this: $ myapp --meeting 2019-08-12T15:04:05 When the layout doesn't contain timezones, timestamp will render with UTC. To change behavior, a default timezone can be provided with flag definition: package main import ( \"log\" \"time\" \"os\" \"github.com/urfave/cli/v2\" ) func main () { app := & cli . App { Flags : [] cli . Flag { & cli . TimestampFlag { Name : \"meeting\" , Layout : \"2006-01-02T15:04:05\" , Timezone : time . Local }, }, } if err := app . Run ( os . Args ); err != nil { log . Fatal ( err ) } } (time.Local contains the system's local time zone.) Side note: quotes may be necessary around the date depending on your layout (if you have spaces for instance)","title":"Timestamp Flag"},{"boost":2,"location":"v2/examples/version-flag/","tags":["v2"],"text":"The default version flag ( -v/--version ) is defined as cli.VersionFlag , which is checked by the cli internals in order to print the App.Version via cli.VersionPrinter and break execution. Customization \u00b6 The default flag may be customized to something other than -v/--version by setting cli.VersionFlag , e.g.: package main import ( \"os\" \"github.com/urfave/cli/v2\" ) func main () { cli . VersionFlag = & cli . BoolFlag { Name : \"print-version\" , Aliases : [] string { \"V\" }, Usage : \"print only the version\" , } app := & cli . App { Name : \"partay\" , Version : \"v19.99.0\" , } app . Run ( os . Args ) } Alternatively, the version printer at cli.VersionPrinter may be overridden, e.g.: package main import ( \"fmt\" \"os\" \"github.com/urfave/cli/v2\" ) var ( Revision = \"fafafaf\" ) func main () { cli . VersionPrinter = func ( cCtx * cli . Context ) { fmt . Printf ( \"version=%s revision=%s\\n\" , cCtx . App . Version , Revision ) } app := & cli . App { Name : \"partay\" , Version : \"v19.99.0\" , } app . Run ( os . Args ) }","title":"Version Flag"},{"boost":2,"location":"v2/examples/version-flag/#customization","text":"The default flag may be customized to something other than -v/--version by setting cli.VersionFlag , e.g.: package main import ( \"os\" \"github.com/urfave/cli/v2\" ) func main () { cli . VersionFlag = & cli . BoolFlag { Name : \"print-version\" , Aliases : [] string { \"V\" }, Usage : \"print only the version\" , } app := & cli . App { Name : \"partay\" , Version : \"v19.99.0\" , } app . Run ( os . Args ) } Alternatively, the version printer at cli.VersionPrinter may be overridden, e.g.: package main import ( \"fmt\" \"os\" \"github.com/urfave/cli/v2\" ) var ( Revision = \"fafafaf\" ) func main () { cli . VersionPrinter = func ( cCtx * cli . Context ) { fmt . Printf ( \"version=%s revision=%s\\n\" , cCtx . App . Version , Revision ) } app := & cli . App { Name : \"partay\" , Version : \"v19.99.0\" , } app . Run ( os . Args ) }","title":"Customization"}]}